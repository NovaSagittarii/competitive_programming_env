{
	"kactl/combinatorial/IntPerm.h": {
		"scope": "cpp",
		"prefix": "kactl/combinatorial/IntPerm.h",
		"body": [
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2018-07-06",
			" * License: CC0",
			" * Description: Permutation -> integer conversion. (Not order preserving.)",
			" * Integer -> permutation can use a lookup table.",
			" * Time: O(n)",
			" */",
			"int permToInt(vi& v) {",
			"\tint use = 0, i = 0, r = 0;",
			"\tfor(int x:v) r = r * ++i + __builtin_popcount(use & -(1<<x)),",
			"\t\tuse |= 1 << x;                     // (note: minus, not ~!)",
			"\treturn r;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/combinatorial/multinomial.h": {
		"scope": "cpp",
		"prefix": "kactl/combinatorial/multinomial.h",
		"body": [
			"/**",
			" * Author: Mattias de Zalenski, Fredrik Niemel\u00e4, Per Austrin, Simon Lindholm",
			" * Date: 2002-09-26",
			" * Source: Max Bennedich",
			" * Description: Computes \\$\\displaystyle \\binom{k_1 + \\dots + k_n}{k_1, k_2, \\dots, k_n} = \\frac{(\\sum k_i)!}{k_1!k_2!...k_n!}\\$.",
			" * Status: Tested on kattis:lexicography",
			" */",
			"ll multinomial(vi& v) {",
			"\tll c = 1, m = v.empty() ? 1 : v[0];",
			"\trep(i,1,sz(v)) rep(j,0,v[i]) c = c * ++m / (j+1);",
			"\treturn c;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/various/KnuthDP.h": {
		"scope": "cpp",
		"prefix": "kactl/various/KnuthDP.h",
		"body": [
			"/**",
			" * Author: Simon Lindholm",
			" * License: CC0",
			" * Source: http://codeforces.com/blog/entry/8219",
			" * Description: When doing DP on intervals: \\$a[i][j] = \\min_{i < k < j}(a[i][k] + a[k][j]) + f(i, j)\\$, where the (minimal) optimal \\$k\\$ increases with both \\$i\\$ and \\$j\\$,",
			" *  one can solve intervals in increasing order of length, and search \\$k = p[i][j]\\$ for \\$a[i][j]\\$ only between \\$p[i][j-1]\\$ and \\$p[i+1][j]\\$.",
			" *  This is known as Knuth DP. Sufficient criteria for this are if \\$f(b,c) \\le f(a,d)\\$ and \\$f(a,c) + f(b,d) \\le f(a,d) + f(b,c)\\$ for all \\$a \\le b \\le c \\le d\\$.",
			" *  Consider also: LineContainer (ch. Data structures), monotone queues, ternary search.",
			" * Time: O(N^2)",
			" */",
			"",
			"$0",
		],
	},
	"kactl/various/Unrolling.h": {
		"scope": "cpp",
		"prefix": "kactl/various/Unrolling.h",
		"body": [
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2015-03-19",
			" * License: CC0",
			" * Source: me",
			" * Description:",
			" */",
			"#define F {...; ++i;}",
			"int i = from;",
			"while (i&3 && i < to) F // for alignment, if needed",
			"while (i + 4 <= to) { F F F F }",
			"while (i < to) F",
			"",
			"$0",
		],
	},
	"kactl/various/DivideAndConquerDP.h": {
		"scope": "cpp",
		"prefix": "kactl/various/DivideAndConquerDP.h",
		"body": [
			"/**",
			" * Author: Simon Lindholm",
			" * License: CC0",
			" * Source: Codeforces",
			" * Description: Given \\$a[i] = \\min_{lo(i) \\le k < hi(i)}(f(i, k))\\$ where the (minimal)",
			" * optimal \\$k\\$ increases with \\$i\\$, computes \\$a[i]\\$ for \\$i = L..R-1\\$.",
			" * Time: O((N + (hi-lo)) \\log N)",
			" * Status: tested on http://codeforces.com/contest/321/problem/E",
			" */",
			"struct DP { // Modify at will:",
			"\tint lo(int ind) { return 0; }",
			"\tint hi(int ind) { return ind; }",
			"\tll f(int ind, int k) { return dp[ind][k]; }",
			"\tvoid store(int ind, int k, ll v) { res[ind] = pii(k, v); }",
			"",
			"\tvoid rec(int L, int R, int LO, int HI) {",
			"\t\tif (L >= R) return;",
			"\t\tint mid = (L + R) >> 1;",
			"\t\tpair<ll, int> best(LLONG_MAX, LO);",
			"\t\trep(k, max(LO,lo(mid)), min(HI,hi(mid)))",
			"\t\t\tbest = min(best, make_pair(f(mid, k), k));",
			"\t\tstore(mid, best.second, best.first);",
			"\t\trec(L, mid, LO, best.second+1);",
			"\t\trec(mid+1, R, best.second, HI);",
			"\t}",
			"\tvoid solve(int L, int R) { rec(L, R, INT_MIN, INT_MAX); }",
			"};",
			"",
			"$0",
		],
	},
	"kactl/various/BumpAllocator.h": {
		"scope": "cpp",
		"prefix": "kactl/various/BumpAllocator.h",
		"body": [
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2015-09-12",
			" * License: CC0",
			" * Source: me",
			" * Description: When you need to dynamically allocate many objects and don't care about freeing them.",
			" * \"new X\" otherwise has an overhead of something like 0.05us + 16 bytes per allocation.",
			" * Status: tested",
			" */",
			"// Either globally or in a single class:",
			"static char buf[450 << 20];",
			"void* operator new(size_t s) {",
			"\tstatic size_t i = sizeof buf;",
			"\tassert(s < i);",
			"\treturn (void*)&buf[i -= s];",
			"}",
			"void operator delete(void*) {}",
			"",
			"$0",
		],
	},
	"kactl/various/FastKnapsack.h": {
		"scope": "cpp",
		"prefix": "kactl/various/FastKnapsack.h",
		"body": [
			"/**",
			" * Author: M\u00e5rten Wiman",
			" * License: CC0",
			" * Source: Pisinger 1999, \"Linear Time Algorithms for Knapsack Problems with Bounded Weights\"",
			" * Description: Given N non-negative integer weights w and a non-negative target t,",
			" * computes the maximum S <= t such that S is the sum of some subset of the weights.",
			" * Time: O(N \\max(w_i))",
			" * Status: Tested on kattis:eavesdropperevasion, stress-tested",
			" */",
			"int knapsack(vi w, int t) {",
			"\tint a = 0, b = 0, x;",
			"\twhile (b < sz(w) && a + w[b] <= t) a += w[b++];",
			"\tif (b == sz(w)) return a;",
			"\tint m = *max_element(all(w));",
			"\tvi u, v(2*m, -1);",
			"\tv[a+m-t] = b;",
			"\trep(i,b,sz(w)) {",
			"\t\tu = v;",
			"\t\trep(x,0,m) v[x+w[i]] = max(v[x+w[i]], u[x]);",
			"\t\tfor (x = 2*m; --x > m;) rep(j, max(0,u[x]), v[x])",
			"\t\t\tv[x-w[j]] = max(v[x-w[j]], j);",
			"\t}",
			"\tfor (a = t; v[a+m-t] < 0; a--) ;",
			"\treturn a;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/various/LIS.h": {
		"scope": "cpp",
		"prefix": "kactl/various/LIS.h",
		"body": [
			"/**",
			" * Author: Johan Sannemo",
			" * License: CC0",
			" * Description: Compute indices for the longest increasing subsequence.",
			" * Time: \\$O(N \\log N)\\$",
			" * Status: Tested on kattis:longincsubseq, stress-tested",
			" */",
			"template<class I> vi lis(const vector<I>& S) {",
			"\tif (S.empty()) return {};",
			"\tvi prev(sz(S));",
			"\ttypedef pair<I, int> p;",
			"\tvector<p> res;",
			"\trep(i,0,sz(S)) {",
			"\t\t// change 0 -> i for longest non-decreasing subsequence",
			"\t\tauto it = lower_bound(all(res), p{S[i], 0});",
			"\t\tif (it == res.end()) res.emplace_back(), it = res.end()-1;",
			"\t\t*it = {S[i], i};",
			"\t\tprev[i] = it == res.begin() ? 0 : (it-1)->second;",
			"\t}",
			"\tint L = sz(res), cur = res.back().second;",
			"\tvi ans(L);",
			"\twhile (L--) ans[L] = cur, cur = prev[cur];",
			"\treturn ans;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/various/SIMD.h": {
		"scope": "cpp",
		"prefix": "kactl/various/SIMD.h",
		"body": [
			"${1:#include \"immintrin.h\" /** keep-include */}",
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2015-03-18",
			" * License: CC0",
			" * Source: https://software.intel.com/sites/landingpage/IntrinsicsGuide/",
			" * Description: Cheat sheet of SSE/AVX intrinsics, for doing arithmetic on several numbers at once.",
			" * Can provide a constant factor improvement of about 4, orthogonal to loop unrolling.",
			" * Operations follow the pattern \\texttt{\"\\_mm(256)?\\_name\\_(si(128|256)|epi(8|16|32|64)|pd|ps)\"}. Not all are described here;",
			" * grep for \\texttt{\\_mm\\_} in \\texttt{/usr/lib/gcc/{*}/4.9/include/} for more.",
			" * If AVX is unsupported, try 128-bit operations, \"emmintrin.h\" and \\#define \\texttt{\\_\\_SSE\\_\\_} and \\texttt{\\_\\_MMX\\_\\_} before including it.",
			" * For aligned memory use \\texttt{\\_mm\\_malloc(size, 32)} or \\texttt{int buf[N] alignas(32)}, but prefer loadu/storeu.",
			" */",
			"",
			"typedef __m256i mi;",
			"#define L(x) _mm256_loadu_si256((mi*)&(x))",
			"",
			"// High-level/specific methods:",
			"// load(u)?_si256, store(u)?_si256, setzero_si256, _mm_malloc",
			"// blendv_(epi8|ps|pd) (z?y:x), movemask_epi8 (hibits of bytes)",
			"// i32gather_epi32(addr, x, 4): map addr[] over 32-b parts of x",
			"// sad_epu8: sum of absolute differences of u8, outputs 4xi64",
			"// maddubs_epi16: dot product of unsigned i7's, outputs 16xi15",
			"// madd_epi16: dot product of signed i16's, outputs 8xi32",
			"// extractf128_si256(, i) (256->128), cvtsi128_si32 (128->lo32)",
			"// permute2f128_si256(x,x,1) swaps 128-bit lanes",
			"// shuffle_epi32(x, 3*64+2*16+1*4+0) == x for each lane",
			"// shuffle_epi8(x, y) takes a vector instead of an imm",
			"",
			"// Methods that work with most data types (append e.g. _epi32):",
			"// set1, blend (i8?x:y), add, adds (sat.), mullo, sub, and/or,",
			"// andnot, abs, min, max, sign(1,x), cmp(gt|eq), unpack(lo|hi)",
			"",
			"int sumi32(mi m) { union {int v[8]; mi m;} u; u.m = m;",
			"\tint ret = 0; rep(i,0,8) ret += u.v[i]; return ret; }",
			"mi zero() { return _mm256_setzero_si256(); }",
			"mi one() { return _mm256_set1_epi32(-1); }",
			"bool all_zero(mi m) { return _mm256_testz_si256(m, m); }",
			"bool all_one(mi m) { return _mm256_testc_si256(m, one()); }",
			"",
			"ll example_filteredDotProduct(int n, short* a, short* b) {",
			"\tint i = 0; ll r = 0;",
			"\tmi zero = _mm256_setzero_si256(), acc = zero;",
			"\twhile (i + 16 <= n) {",
			"\t\tmi va = L(a[i]), vb = L(b[i]); i += 16;",
			"\t\tva = _mm256_and_si256(_mm256_cmpgt_epi16(vb, va), va);",
			"\t\tmi vp = _mm256_madd_epi16(va, vb);",
			"\t\tacc = _mm256_add_epi64(_mm256_unpacklo_epi32(vp, zero),",
			"\t\t\t_mm256_add_epi64(acc, _mm256_unpackhi_epi32(vp, zero)));",
			"\t}",
			"\tunion {ll v[4]; mi m;} u; u.m = acc; rep(i,0,4) r += u.v[i];",
			"\tfor (;i<n;++i) if (a[i] < b[i]) r += a[i]*b[i]; // <- equiv",
			"\treturn r;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/various/SmallPtr.h": {
		"scope": "cpp",
		"prefix": "kactl/various/SmallPtr.h",
		"body": [
			"${1:#include \"BumpAllocator.h\"}",
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2016-08-23",
			" * License: CC0",
			" * Source: me",
			" * Description: A 32-bit pointer that points into BumpAllocator memory.",
			" * Status: tested",
			" */",
			"",
			"template<class T> struct ptr {",
			"\tunsigned ind;",
			"\tptr(T* p = 0) : ind(p ? unsigned((char*)p - buf) : 0) {",
			"\t\tassert(ind < sizeof buf);",
			"\t}",
			"\tT& operator*() const { return *(T*)(buf + ind); }",
			"\tT* operator->() const { return &**this; }",
			"\tT& operator[](int a) const { return (&**this)[a]; }",
			"\texplicit operator bool() const { return ind; }",
			"};",
			"",
			"$0",
		],
	},
	"kactl/various/FastMod.h": {
		"scope": "cpp",
		"prefix": "kactl/various/FastMod.h",
		"body": [
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2020-05-30",
			" * License: CC0",
			" * Source: https://en.wikipedia.org/wiki/Barrett_reduction",
			" * Description: Compute \\$a \\% b\\$ about 5 times faster than usual, where \\$b\\$ is constant but not known at compile time.",
			" * Returns a value congruent to \\$a \\pmod b\\$ in the range \\$[0, 2b)\\$.",
			" * Status: proven correct, stress-tested",
			" * Measured as having 4 times lower latency, and 8 times higher throughput, see stress-test.",
			" * Details:",
			" * More precisely, it can be proven that the result equals 0 only if \\$a = 0\\$,",
			" * and otherwise lies in \\$[1, (1 + a/2^64) * b)\\$.",
			" */",
			"typedef unsigned long long ull;",
			"struct FastMod {",
			"\tull b, m;",
			"\tFastMod(ull b) : b(b), m(-1ULL / b) {}",
			"\tull reduce(ull a) { // a % b + (0 or b)",
			"\t\treturn a - (ull)((__uint128_t(m) * a) >> 64) * b;",
			"\t}",
			"};",
			"",
			"$0",
		],
	},
	"kactl/various/ConstantIntervals.h": {
		"scope": "cpp",
		"prefix": "kactl/various/ConstantIntervals.h",
		"body": [
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2015-03-20",
			" * License: CC0",
			" * Source: me",
			" * Description: Split a monotone function on [from, to) into a minimal set of half-open intervals on which it has the same value.",
			" *  Runs a callback g for each such interval.",
			" * Usage: constantIntervals(0, sz(v), [\\&](int x){return v[x];}, [\\&](int lo, int hi, T val){...});",
			" * Time: O(k\\log\\frac{n}{k})",
			" * Status: tested",
			" */",
			"template<class F, class G, class T>",
			"void rec(int from, int to, F& f, G& g, int& i, T& p, T q) {",
			"\tif (p == q) return;",
			"\tif (from == to) {",
			"\t\tg(i, to, p);",
			"\t\ti = to; p = q;",
			"\t} else {",
			"\t\tint mid = (from + to) >> 1;",
			"\t\trec(from, mid, f, g, i, p, f(mid));",
			"\t\trec(mid+1, to, f, g, i, p, q);",
			"\t}",
			"}",
			"template<class F, class G>",
			"void constantIntervals(int from, int to, F f, G g) {",
			"\tif (to <= from) return;",
			"\tint i = from; auto p = f(i), q = f(to-1);",
			"\trec(from, to-1, f, g, i, p, q);",
			"\tg(i, to, q);",
			"}",
			"",
			"$0",
		],
	},
	"kactl/various/IntervalCover.h": {
		"scope": "cpp",
		"prefix": "kactl/various/IntervalCover.h",
		"body": [
			"/**",
			" * Author: Johan Sannemo",
			" * License: CC0",
			" * Description: Compute indices of smallest set of intervals covering another interval.",
			" * Intervals should be [inclusive, exclusive). To support [inclusive, inclusive],",
			" * change (A) to add \\texttt{|| R.empty()}. Returns empty set on failure (or if G is empty).",
			" * Time: O(N \\log N)",
			" * Status: Tested on kattis:intervalcover",
			" */",
			"template<class T>",
			"vi cover(pair<T, T> G, vector<pair<T, T>> I) {",
			"\tvi S(sz(I)), R;",
			"\tiota(all(S), 0);",
			"\tsort(all(S), [&](int a, int b) { return I[a] < I[b]; });",
			"\tT cur = G.first;",
			"\tint at = 0;",
			"\twhile (cur < G.second) { // (A)",
			"\t\tpair<T, int> mx = make_pair(cur, -1);",
			"\t\twhile (at < sz(I) && I[S[at]].first <= cur) {",
			"\t\t\tmx = max(mx, make_pair(I[S[at]].second, S[at]));",
			"\t\t\tat++;",
			"\t\t}",
			"\t\tif (mx.second == -1) return {};",
			"\t\tcur = mx.first;",
			"\t\tR.push_back(mx.second);",
			"\t}",
			"\treturn R;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/various/BumpAllocatorSTL.h": {
		"scope": "cpp",
		"prefix": "kactl/various/BumpAllocatorSTL.h",
		"body": [
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2016-07-23",
			" * License: CC0",
			" * Source: me",
			" * Description: BumpAllocator for STL containers.",
			" * Usage: vector<vector<int, small<int>>> ed(N);",
			" * Status: tested",
			" */",
			"char buf[450 << 20] alignas(16);",
			"size_t buf_ind = sizeof buf;",
			"",
			"template<class T> struct small {",
			"\ttypedef T value_type;",
			"\tsmall() {}",
			"\ttemplate<class U> small(const U&) {}",
			"\tT* allocate(size_t n) {",
			"\t\tbuf_ind -= n * sizeof(T);",
			"\t\tbuf_ind &= 0 - alignof(T);",
			"\t\treturn (T*)(buf + buf_ind);",
			"\t}",
			"\tvoid deallocate(T*, size_t) {}",
			"};",
			"",
			"$0",
		],
	},
	"kactl/various/TernarySearch.h": {
		"scope": "cpp",
		"prefix": "kactl/various/TernarySearch.h",
		"body": [
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2015-05-12",
			" * License: CC0",
			" * Source: own work",
			" * Description:",
			" * Find the smallest i in \\$[a,b]\\$ that maximizes \\$f(i)\\$, assuming that \\$f(a) < \\dots < f(i) \\ge \\dots \\ge f(b)\\$.",
			" * To reverse which of the sides allows non-strict inequalities, change the < marked with (A) to <=, and reverse the loop at (B).",
			" * To minimize \\$f\\$, change it to >, also at (B).",
			" * Usage:",
			"\tint ind = ternSearch(0,n-1,[\\&](int i){return a[i];});",
			" * Time: O(\\log(b-a))",
			" * Status: tested",
			" */",
			"template<class F>",
			"int ternSearch(int a, int b, F f) {",
			"\tassert(a <= b);",
			"\twhile (b - a >= 5) {",
			"\t\tint mid = (a + b) / 2;",
			"\t\tif (f(mid) < f(mid+1)) a = mid; // (A)",
			"\t\telse b = mid+1;",
			"\t}",
			"\trep(i,a+1,b+1) if (f(a) < f(i)) a = i; // (B)",
			"\treturn a;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/various/IntervalContainer.h": {
		"scope": "cpp",
		"prefix": "kactl/various/IntervalContainer.h",
		"body": [
			"/**",
			" * Author: Simon Lindholm",
			" * License: CC0",
			" * Description: Add and remove intervals from a set of disjoint intervals.",
			" * Will merge the added interval with any overlapping intervals in the set when adding.",
			" * Intervals are [inclusive, exclusive).",
			" * Time: O(\\log N)",
			" * Status: stress-tested",
			" */",
			"set<pii>::iterator addInterval(set<pii>& is, int L, int R) {",
			"\tif (L == R) return is.end();",
			"\tauto it = is.lower_bound({L, R}), before = it;",
			"\twhile (it != is.end() && it->first <= R) {",
			"\t\tR = max(R, it->second);",
			"\t\tbefore = it = is.erase(it);",
			"\t}",
			"\tif (it != is.begin() && (--it)->second >= L) {",
			"\t\tL = min(L, it->first);",
			"\t\tR = max(R, it->second);",
			"\t\tis.erase(it);",
			"\t}",
			"\treturn is.insert(before, {L,R});",
			"}",
			"",
			"void removeInterval(set<pii>& is, int L, int R) {",
			"\tif (L == R) return;",
			"\tauto it = addInterval(is, L, R);",
			"\tauto r2 = it->second;",
			"\tif (it->first == L) is.erase(it);",
			"\telse (int&)it->second = L;",
			"\tif (R != r2) is.emplace(R, r2);",
			"}",
			"",
			"$0",
		],
	},
	"kactl/various/FastInput.h": {
		"scope": "cpp",
		"prefix": "kactl/various/FastInput.h",
		"body": [
			"/**",
			" * Author: chilli",
			" * License: CC0",
			" * Source: Own work",
			" * Description: Read an integer from stdin. Usage requires your program to pipe in",
			" * input from file.",
			" * Usage: ./a.out < input.txt",
			" * Time: About 5x as fast as cin/scanf.",
			" * Status: tested on SPOJ INTEST, unit tested",
			" */",
			"inline char gc() { // like getchar()",
			"\tstatic char buf[1 << 16];",
			"\tstatic size_t bc, be;",
			"\tif (bc >= be) {",
			"\t\tbuf[0] = 0, bc = 0;",
			"\t\tbe = fread(buf, 1, sizeof(buf), stdin);",
			"\t}",
			"\treturn buf[bc++]; // returns 0 on EOF",
			"}",
			"",
			"int readInt() {",
			"\tint a, c;",
			"\twhile ((a = gc()) < 40);",
			"\tif (a == '-') return -readInt();",
			"\twhile ((c = gc()) >= 48) a = a * 10 + c - 480;",
			"\treturn a - 48;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/data-structures/FenwickTree.h": {
		"scope": "cpp",
		"prefix": "kactl/data-structures/FenwickTree.h",
		"body": [
			"/**",
			" * Author: Lukas Polacek",
			" * Date: 2009-10-30",
			" * License: CC0",
			" * Source: folklore/TopCoder",
			" * Description: Computes partial sums a[0] + a[1] + ... + a[pos - 1], and updates single elements a[i],",
			" * taking the difference between the old and new value.",
			" * Time: Both operations are \\$O(\\log N)\\$.",
			" * Status: Stress-tested",
			" */",
			"struct FT {",
			"\tvector<ll> s;",
			"\tFT(int n) : s(n) {}",
			"\tvoid update(int pos, ll dif) { // a[pos] += dif",
			"\t\tfor (; pos < sz(s); pos |= pos + 1) s[pos] += dif;",
			"\t}",
			"\tll query(int pos) { // sum of values in [0, pos)",
			"\t\tll res = 0;",
			"\t\tfor (; pos > 0; pos &= pos - 1) res += s[pos-1];",
			"\t\treturn res;",
			"\t}",
			"\tint lower_bound(ll sum) {// min pos st sum of [0, pos] >= sum",
			"\t\t// Returns n if no sum is >= sum, or -1 if empty sum is.",
			"\t\tif (sum <= 0) return -1;",
			"\t\tint pos = 0;",
			"\t\tfor (int pw = 1 << 25; pw; pw >>= 1) {",
			"\t\t\tif (pos + pw <= sz(s) && s[pos + pw-1] < sum)",
			"\t\t\t\tpos += pw, sum -= s[pos-1];",
			"\t\t}",
			"\t\treturn pos;",
			"\t}",
			"};",
			"",
			"$0",
		],
	},
	"kactl/data-structures/SegmentTree.h": {
		"scope": "cpp",
		"prefix": "kactl/data-structures/SegmentTree.h",
		"body": [
			"/**",
			" * Author: Lucian Bicsi",
			" * Date: 2017-10-31",
			" * License: CC0",
			" * Source: folklore",
			" * Description: Zero-indexed max-tree. Bounds are inclusive to the left and exclusive to the right.",
			" * Can be changed by modifying T, f and unit.",
			" * Time: O(\\log N)",
			" * Status: stress-tested",
			" */",
			"struct Tree {",
			"\ttypedef int T;",
			"\tstatic constexpr T unit = INT_MIN;",
			"\tT f(T a, T b) { return max(a, b); } // (any associative fn)",
			"\tvector<T> s; int n;",
			"\tTree(int n = 0, T def = unit) : s(2*n, def), n(n) {}",
			"\tvoid update(int pos, T val) {",
			"\t\tfor (s[pos += n] = val; pos /= 2;)",
			"\t\t\ts[pos] = f(s[pos * 2], s[pos * 2 + 1]);",
			"\t}",
			"\tT query(int b, int e) { // query [b, e)",
			"\t\tT ra = unit, rb = unit;",
			"\t\tfor (b += n, e += n; b < e; b /= 2, e /= 2) {",
			"\t\t\tif (b % 2) ra = f(ra, s[b++]);",
			"\t\t\tif (e % 2) rb = f(s[--e], rb);",
			"\t\t}",
			"\t\treturn f(ra, rb);",
			"\t}",
			"};",
			"",
			"$0",
		],
	},
	"kactl/data-structures/LineContainer.h": {
		"scope": "cpp",
		"prefix": "kactl/data-structures/LineContainer.h",
		"body": [
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2017-04-20",
			" * License: CC0",
			" * Source: own work",
			" * Description: Container where you can add lines of the form kx+m, and query maximum values at points x.",
			" *  Useful for dynamic programming (``convex hull trick'').",
			" * Time: O(\\log N)",
			" * Status: stress-tested",
			" */",
			"struct Line {",
			"\tmutable ll k, m, p;",
			"\tbool operator<(const Line& o) const { return k < o.k; }",
			"\tbool operator<(ll x) const { return p < x; }",
			"};",
			"",
			"struct LineContainer : multiset<Line, less<>> {",
			"\t// (for doubles, use inf = 1/.0, div(a,b) = a/b)",
			"\tstatic const ll inf = LLONG_MAX;",
			"\tll div(ll a, ll b) { // floored division",
			"\t\treturn a / b - ((a ^ b) < 0 && a % b); }",
			"\tbool isect(iterator x, iterator y) {",
			"\t\tif (y == end()) return x->p = inf, 0;",
			"\t\tif (x->k == y->k) x->p = x->m > y->m ? inf : -inf;",
			"\t\telse x->p = div(y->m - x->m, x->k - y->k);",
			"\t\treturn x->p >= y->p;",
			"\t}",
			"\tvoid add(ll k, ll m) {",
			"\t\tauto z = insert({k, m, 0}), y = z++, x = y;",
			"\t\twhile (isect(y, z)) z = erase(z);",
			"\t\tif (x != begin() && isect(--x, y)) isect(x, y = erase(y));",
			"\t\twhile ((y = x) != begin() && (--x)->p >= y->p)",
			"\t\t\tisect(x, erase(y));",
			"\t}",
			"\tll query(ll x) {",
			"\t\tassert(!empty());",
			"\t\tauto l = *lower_bound(x);",
			"\t\treturn l.k * x + l.m;",
			"\t}",
			"};",
			"",
			"$0",
		],
	},
	"kactl/data-structures/HashMap.h": {
		"scope": "cpp",
		"prefix": "kactl/data-structures/HashMap.h",
		"body": [
			"${1:#include <bits/extc++.h> /** keep-include */}",
			"/**",
			" * Author: Simon Lindholm, chilli",
			" * Date: 2018-07-23",
			" * License: CC0",
			" * Source: http://codeforces.com/blog/entry/60737",
			" * Description: Hash map with mostly the same API as unordered\\_map, but \\tilde",
			" * 3x faster. Uses 1.5x memory.",
			" * Initial capacity must be a power of 2 (if provided).",
			" */",
			"// To use most bits rather than just the lowest ones:",
			"struct chash { // large odd number for C",
			"\tconst uint64_t C = ll(4e18 * acos(0)) | 71;",
			"\tll operator()(ll x) const { return __builtin_bswap64(x*C); }",
			"};",
			"__gnu_pbds::gp_hash_table<ll,int,chash> h({},{},{},{},{1<<16});",
			"",
			"/** For CodeForces, or other places where hacking might be a problem:",
			"",
			"const int RANDOM = chrono::high_resolution_clock::now().time_since_epoch().count();",
			"struct chash { // To use most bits rather than just the lowest ones:",
			"\tconst uint64_t C = ll(4e18 * acos(0)) | 71; // large odd number",
			"\tll operator()(ll x) const { return __builtin_bswap64((x^RANDOM)*C); }",
			"};",
			"__gnu_pbds::gp_hash_table<ll, int, chash> h({},{},{},{}, {1 << 16});",
			"*/",
			"",
			"$0",
		],
	},
	"kactl/data-structures/MoQueries.h": {
		"scope": "cpp",
		"prefix": "kactl/data-structures/MoQueries.h",
		"body": [
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2019-12-28",
			" * License: CC0",
			" * Source: https://github.com/hoke-t/tamu-kactl/blob/master/content/data-structures/MoQueries.h",
			" * Description: Answer interval or tree path queries by finding an approximate TSP through the queries,",
			" * and moving from one query to the next by adding/removing points at the ends.",
			" * If values are on tree edges, change \\texttt{step} to add/remove the edge \\$(a, c)\\$ and remove the initial \\texttt{add} call (but keep \\texttt{in}).",
			" * Time: O(N \\sqrt Q)",
			" * Status: stress-tested",
			" */",
			"void add(int ind, int end) { ... } // add a[ind] (end = 0 or 1)",
			"void del(int ind, int end) { ... } // remove a[ind]",
			"int calc() { ... } // compute current answer",
			"",
			"vi mo(vector<pii> Q) {",
			"\tint L = 0, R = 0, blk = 350; // ~N/sqrt(Q)",
			"\tvi s(sz(Q)), res = s;",
			"#define K(x) pii(x.first/blk, x.second ^ -(x.first/blk & 1))",
			"\tiota(all(s), 0);",
			"\tsort(all(s), [&](int s, int t){ return K(Q[s]) < K(Q[t]); });",
			"\tfor (int qi : s) {",
			"\t\tpii q = Q[qi];",
			"\t\twhile (L > q.first) add(--L, 0);",
			"\t\twhile (R < q.second) add(R++, 1);",
			"\t\twhile (L < q.first) del(L++, 0);",
			"\t\twhile (R > q.second) del(--R, 1);",
			"\t\tres[qi] = calc();",
			"\t}",
			"\treturn res;",
			"}",
			"",
			"vi moTree(vector<array<int, 2>> Q, vector<vi>& ed, int root=0){",
			"\tint N = sz(ed), pos[2] = {}, blk = 350; // ~N/sqrt(Q)",
			"\tvi s(sz(Q)), res = s, I(N), L(N), R(N), in(N), par(N);",
			"\tadd(0, 0), in[0] = 1;",
			"\tauto dfs = [&](int x, int p, int dep, auto& f) -> void {",
			"\t\tpar[x] = p;",
			"\t\tL[x] = N;",
			"\t\tif (dep) I[x] = N++;",
			"\t\tfor (int y : ed[x]) if (y != p) f(y, x, !dep, f);",
			"\t\tif (!dep) I[x] = N++;",
			"\t\tR[x] = N;",
			"\t};",
			"\tdfs(root, -1, 0, dfs);",
			"#define K(x) pii(I[x[0]] / blk, I[x[1]] ^ -(I[x[0]] / blk & 1))",
			"\tiota(all(s), 0);",
			"\tsort(all(s), [&](int s, int t){ return K(Q[s]) < K(Q[t]); });",
			"\tfor (int qi : s) rep(end,0,2) {",
			"\t\tint &a = pos[end], b = Q[qi][end], i = 0;",
			"#define step(c) { if (in[c]) { del(a, end); in[a] = 0; } \\",
			"                  else { add(c, end); in[c] = 1; } a = c; }",
			"\t\twhile (!(L[b] <= L[a] && R[a] <= R[b]))",
			"\t\t\tI[i++] = b, b = par[b];",
			"\t\twhile (a != b) step(par[a]);",
			"\t\twhile (i--) step(I[i]);",
			"\t\tif (end) res[qi] = calc();",
			"\t}",
			"\treturn res;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/data-structures/SubMatrix.h": {
		"scope": "cpp",
		"prefix": "kactl/data-structures/SubMatrix.h",
		"body": [
			"/**",
			" * Author: Johan Sannemo",
			" * Date: 2014-11-28",
			" * License: CC0",
			" * Source: Folklore",
			" * Description: Calculate submatrix sums quickly, given upper-left and lower-right corners (half-open).",
			" * Usage:",
			" * SubMatrix<int> m(matrix);",
			" * m.sum(0, 0, 2, 2); // top left 4 elements",
			" * Time: O(N^2 + Q)",
			" * Status: Tested on Kattis",
			" */",
			"template<class T>",
			"struct SubMatrix {",
			"\tvector<vector<T>> p;",
			"\tSubMatrix(vector<vector<T>>& v) {",
			"\t\tint R = sz(v), C = sz(v[0]);",
			"\t\tp.assign(R+1, vector<T>(C+1));",
			"\t\trep(r,0,R) rep(c,0,C)",
			"\t\t\tp[r+1][c+1] = v[r][c] + p[r][c+1] + p[r+1][c] - p[r][c];",
			"\t}",
			"\tT sum(int u, int l, int d, int r) {",
			"\t\treturn p[d][r] - p[d][l] - p[u][r] + p[u][l];",
			"\t}",
			"};",
			"",
			"$0",
		],
	},
	"kactl/data-structures/Treap.h": {
		"scope": "cpp",
		"prefix": "kactl/data-structures/Treap.h",
		"body": [
			"/**",
			" * Author: someone on Codeforces",
			" * Date: 2017-03-14",
			" * Source: folklore",
			" * Description: A short self-balancing tree. It acts as a",
			" *  sequential container with log-time splits/joins, and",
			" *  is easy to augment with additional data.",
			" * Time: \\$O(\\log N)\\$",
			" * Status: stress-tested",
			" */",
			"struct Node {",
			"\tNode *l = 0, *r = 0;",
			"\tint val, y, c = 1;",
			"\tNode(int val) : val(val), y(rand()) {}",
			"\tvoid recalc();",
			"};",
			"",
			"int cnt(Node* n) { return n ? n->c : 0; }",
			"void Node::recalc() { c = cnt(l) + cnt(r) + 1; }",
			"",
			"template<class F> void each(Node* n, F f) {",
			"\tif (n) { each(n->l, f); f(n->val); each(n->r, f); }",
			"}",
			"",
			"pair<Node*, Node*> split(Node* n, int k) {",
			"\tif (!n) return {};",
			"\tif (cnt(n->l) >= k) { // \"n->val >= k\" for lower_bound(k)",
			"\t\tauto [L,R] = split(n->l, k);",
			"\t\tn->l = R;",
			"\t\tn->recalc();",
			"\t\treturn {L, n};",
			"\t} else {",
			"\t\tauto [L,R] = split(n->r,k - cnt(n->l) - 1); // and just \"k\"",
			"\t\tn->r = L;",
			"\t\tn->recalc();",
			"\t\treturn {n, R};",
			"\t}",
			"}",
			"",
			"Node* merge(Node* l, Node* r) {",
			"\tif (!l) return r;",
			"\tif (!r) return l;",
			"\tif (l->y > r->y) {",
			"\t\tl->r = merge(l->r, r);",
			"\t\treturn l->recalc(), l;",
			"\t} else {",
			"\t\tr->l = merge(l, r->l);",
			"\t\treturn r->recalc(), r;",
			"\t}",
			"}",
			"",
			"Node* ins(Node* t, Node* n, int pos) {",
			"\tauto [l,r] = split(t, pos);",
			"\treturn merge(merge(l, n), r);",
			"}",
			"",
			"// Example application: move the range [l, r) to index k",
			"void move(Node*& t, int l, int r, int k) {",
			"\tNode *a, *b, *c;",
			"\ttie(a,b) = split(t, l); tie(b,c) = split(b, r - l);",
			"\tif (k <= l) t = merge(ins(a, b, k), c);",
			"\telse t = merge(a, ins(c, b, k - r));",
			"}",
			"",
			"$0",
		],
	},
	"kactl/data-structures/RMQ.h": {
		"scope": "cpp",
		"prefix": "kactl/data-structures/RMQ.h",
		"body": [
			"/**",
			" * Author: Johan Sannemo, pajenegod",
			" * Date: 2015-02-06",
			" * License: CC0",
			" * Source: Folklore",
			" * Description: Range Minimum Queries on an array. Returns",
			" * min(V[a], V[a + 1], ... V[b - 1]) in constant time.",
			" * Usage:",
			" *  RMQ rmq(values);",
			" *  rmq.query(inclusive, exclusive);",
			" * Time: \\$O(|V| \\log |V| + Q)\\$",
			" * Status: stress-tested",
			" */",
			"template<class T>",
			"struct RMQ {",
			"\tvector<vector<T>> jmp;",
			"\tRMQ(const vector<T>& V) : jmp(1, V) {",
			"\t\tfor (int pw = 1, k = 1; pw * 2 <= sz(V); pw *= 2, ++k) {",
			"\t\t\tjmp.emplace_back(sz(V) - pw * 2 + 1);",
			"\t\t\trep(j,0,sz(jmp[k]))",
			"\t\t\t\tjmp[k][j] = min(jmp[k - 1][j], jmp[k - 1][j + pw]);",
			"\t\t}",
			"\t}",
			"\tT query(int a, int b) {",
			"\t\tassert(a < b); // or return inf if a == b",
			"\t\tint dep = 31 - __builtin_clz(b - a);",
			"\t\treturn min(jmp[dep][a], jmp[dep][b - (1 << dep)]);",
			"\t}",
			"};",
			"",
			"$0",
		],
	},
	"kactl/data-structures/OrderStatisticTree.h": {
		"scope": "cpp",
		"prefix": "kactl/data-structures/OrderStatisticTree.h",
		"body": [
			"${1:#include <bits/extc++.h> /** keep-include */}",
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2016-03-22",
			" * License: CC0",
			" * Source: hacKIT, NWERC 2015",
			" * Description: A set (not multiset!) with support for finding the n'th",
			" * element, and finding the index of an element.",
			" * To get a map, change \\texttt{null\\_type}.",
			" * Time: O(\\log N)",
			" */",
			"using namespace __gnu_pbds;",
			"",
			"template<class T>",
			"using Tree = tree<T, null_type, less<T>, rb_tree_tag,",
			"    tree_order_statistics_node_update>;",
			"",
			"void example() {",
			"\tTree<int> t, t2; t.insert(8);",
			"\tauto it = t.insert(10).first;",
			"\tassert(it == t.lower_bound(9));",
			"\tassert(t.order_of_key(10) == 1);",
			"\tassert(t.order_of_key(11) == 2);",
			"\tassert(*t.find_by_order(0) == 8);",
			"\tt.join(t2); // assuming T < T2 or T > T2, merge t2 into t",
			"}",
			"",
			"$0",
		],
	},
	"kactl/data-structures/UnionFind.h": {
		"scope": "cpp",
		"prefix": "kactl/data-structures/UnionFind.h",
		"body": [
			"/**",
			" * Author: Lukas Polacek",
			" * Date: 2009-10-26",
			" * License: CC0",
			" * Source: folklore",
			" * Description: Disjoint-set data structure.",
			" * Time: \\$O(\\alpha(N))\\$",
			" */",
			"struct UF {",
			"\tvi e;",
			"\tUF(int n) : e(n, -1) {}",
			"\tbool sameSet(int a, int b) { return find(a) == find(b); }",
			"\tint size(int x) { return -e[find(x)]; }",
			"\tint find(int x) { return e[x] < 0 ? x : e[x] = find(e[x]); }",
			"\tbool join(int a, int b) {",
			"\t\ta = find(a), b = find(b);",
			"\t\tif (a == b) return false;",
			"\t\tif (e[a] > e[b]) swap(a, b);",
			"\t\te[a] += e[b]; e[b] = a;",
			"\t\treturn true;",
			"\t}",
			"};",
			"",
			"$0",
		],
	},
	"kactl/data-structures/LazySegmentTree.h": {
		"scope": "cpp",
		"prefix": "kactl/data-structures/LazySegmentTree.h",
		"body": [
			"${1:#include \"../various/BumpAllocator.h\"}",
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2016-10-08",
			" * License: CC0",
			" * Source: me",
			" * Description: Segment tree with ability to add or set values of large intervals, and compute max of intervals.",
			" * Can be changed to other things.",
			" * Use with a bump allocator for better performance, and SmallPtr or implicit indices to save memory.",
			" * Time: O(\\log N).",
			" * Usage: Node* tr = new Node(v, 0, sz(v));",
			" * Status: stress-tested a bit",
			" */",
			"",
			"const int inf = 1e9;",
			"struct Node {",
			"\tNode *l = 0, *r = 0;",
			"\tint lo, hi, mset = inf, madd = 0, val = -inf;",
			"\tNode(int lo,int hi):lo(lo),hi(hi){} // Large interval of -inf",
			"\tNode(vi& v, int lo, int hi) : lo(lo), hi(hi) {",
			"\t\tif (lo + 1 < hi) {",
			"\t\t\tint mid = lo + (hi - lo)/2;",
			"\t\t\tl = new Node(v, lo, mid); r = new Node(v, mid, hi);",
			"\t\t\tval = max(l->val, r->val);",
			"\t\t}",
			"\t\telse val = v[lo];",
			"\t}",
			"\tint query(int L, int R) {",
			"\t\tif (R <= lo || hi <= L) return -inf;",
			"\t\tif (L <= lo && hi <= R) return val;",
			"\t\tpush();",
			"\t\treturn max(l->query(L, R), r->query(L, R));",
			"\t}",
			"\tvoid set(int L, int R, int x) {",
			"\t\tif (R <= lo || hi <= L) return;",
			"\t\tif (L <= lo && hi <= R) mset = val = x, madd = 0;",
			"\t\telse {",
			"\t\t\tpush(), l->set(L, R, x), r->set(L, R, x);",
			"\t\t\tval = max(l->val, r->val);",
			"\t\t}",
			"\t}",
			"\tvoid add(int L, int R, int x) {",
			"\t\tif (R <= lo || hi <= L) return;",
			"\t\tif (L <= lo && hi <= R) {",
			"\t\t\tif (mset != inf) mset += x;",
			"\t\t\telse madd += x;",
			"\t\t\tval += x;",
			"\t\t}",
			"\t\telse {",
			"\t\t\tpush(), l->add(L, R, x), r->add(L, R, x);",
			"\t\t\tval = max(l->val, r->val);",
			"\t\t}",
			"\t}",
			"\tvoid push() {",
			"\t\tif (!l) {",
			"\t\t\tint mid = lo + (hi - lo)/2;",
			"\t\t\tl = new Node(lo, mid); r = new Node(mid, hi);",
			"\t\t}",
			"\t\tif (mset != inf)",
			"\t\t\tl->set(lo,hi,mset), r->set(lo,hi,mset), mset = inf;",
			"\t\telse if (madd)",
			"\t\t\tl->add(lo,hi,madd), r->add(lo,hi,madd), madd = 0;",
			"\t}",
			"};",
			"",
			"$0",
		],
	},
	"kactl/data-structures/FenwickTree2d.h": {
		"scope": "cpp",
		"prefix": "kactl/data-structures/FenwickTree2d.h",
		"body": [
			"${1:#include \"FenwickTree.h\"}",
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2017-05-11",
			" * License: CC0",
			" * Source: folklore",
			" * Description: Computes sums a[i,j] for all i<I, j<J, and increases single elements a[i,j].",
			" *  Requires that the elements to be updated are known in advance (call fakeUpdate() before init()).",
			" * Time: \\$O(\\log^2 N)\\$. (Use persistent segment trees for \\$O(\\log N)\\$.)",
			" * Status: stress-tested",
			" */",
			"",
			"struct FT2 {",
			"\tvector<vi> ys; vector<FT> ft;",
			"\tFT2(int limx) : ys(limx) {}",
			"\tvoid fakeUpdate(int x, int y) {",
			"\t\tfor (; x < sz(ys); x |= x + 1) ys[x].push_back(y);",
			"\t}",
			"\tvoid init() {",
			"\t\tfor (vi& v : ys) sort(all(v)), ft.emplace_back(sz(v));",
			"\t}",
			"\tint ind(int x, int y) {",
			"\t\treturn (int)(lower_bound(all(ys[x]), y) - ys[x].begin()); }",
			"\tvoid update(int x, int y, ll dif) {",
			"\t\tfor (; x < sz(ys); x |= x + 1)",
			"\t\t\tft[x].update(ind(x, y), dif);",
			"\t}",
			"\tll query(int x, int y) {",
			"\t\tll sum = 0;",
			"\t\tfor (; x; x &= x - 1)",
			"\t\t\tsum += ft[x-1].query(ind(x-1, y));",
			"\t\treturn sum;",
			"\t}",
			"};",
			"",
			"$0",
		],
	},
	"kactl/data-structures/Matrix.h": {
		"scope": "cpp",
		"prefix": "kactl/data-structures/Matrix.h",
		"body": [
			"/**",
			" * Author: Ulf Lundstrom",
			" * Date: 2009-08-03",
			" * License: CC0",
			" * Source: My head",
			" * Description: Basic operations on square matrices.",
			" * Usage: Matrix<int, 3> A;",
			" *  A.d = {{{{1,2,3}}, {{4,5,6}}, {{7,8,9}}}};",
			" *  array<int, 3> vec = {1,2,3};",
			" *  vec = (A^N) * vec;",
			" * Status: tested",
			" */",
			"template<class T, int N> struct Matrix {",
			"\ttypedef Matrix M;",
			"\tarray<array<T, N>, N> d{};",
			"\tM operator*(const M& m) const {",
			"\t\tM a;",
			"\t\trep(i,0,N) rep(j,0,N)",
			"\t\t\trep(k,0,N) a.d[i][j] += d[i][k]*m.d[k][j];",
			"\t\treturn a;",
			"\t}",
			"\tarray<T, N> operator*(const array<T, N>& vec) const {",
			"\t\tarray<T, N> ret{};",
			"\t\trep(i,0,N) rep(j,0,N) ret[i] += d[i][j] * vec[j];",
			"\t\treturn ret;",
			"\t}",
			"\tM operator^(ll p) const {",
			"\t\tassert(p >= 0);",
			"\t\tM a, b(*this);",
			"\t\trep(i,0,N) a.d[i][i] = 1;",
			"\t\twhile (p) {",
			"\t\t\tif (p&1) a = a*b;",
			"\t\t\tb = b*b;",
			"\t\t\tp >>= 1;",
			"\t\t}",
			"\t\treturn a;",
			"\t}",
			"};",
			"",
			"$0",
		],
	},
	"kactl/data-structures/UnionFindRollback.h": {
		"scope": "cpp",
		"prefix": "kactl/data-structures/UnionFindRollback.h",
		"body": [
			"/**",
			" * Author: Lukas Polacek, Simon Lindholm",
			" * Date: 2019-12-26",
			" * License: CC0",
			" * Source: folklore",
			" * Description: Disjoint-set data structure with undo.",
			" * If undo is not needed, skip st, time() and rollback().",
			" * Usage: int t = uf.time(); ...; uf.rollback(t);",
			" * Time: \\$O(\\log(N))\\$",
			" * Status: tested as part of DirectedMST.h",
			" */",
			"struct RollbackUF {",
			"\tvi e; vector<pii> st;",
			"\tRollbackUF(int n) : e(n, -1) {}",
			"\tint size(int x) { return -e[find(x)]; }",
			"\tint find(int x) { return e[x] < 0 ? x : find(e[x]); }",
			"\tint time() { return sz(st); }",
			"\tvoid rollback(int t) {",
			"\t\tfor (int i = time(); i --> t;)",
			"\t\t\te[st[i].first] = st[i].second;",
			"\t\tst.resize(t);",
			"\t}",
			"\tbool join(int a, int b) {",
			"\t\ta = find(a), b = find(b);",
			"\t\tif (a == b) return false;",
			"\t\tif (e[a] > e[b]) swap(a, b);",
			"\t\tst.push_back({a, e[a]});",
			"\t\tst.push_back({b, e[b]});",
			"\t\te[a] += e[b]; e[b] = a;",
			"\t\treturn true;",
			"\t}",
			"};",
			"",
			"$0",
		],
	},
	"kactl/geometry/LineHullIntersection.h": {
		"scope": "cpp",
		"prefix": "kactl/geometry/LineHullIntersection.h",
		"body": [
			"${1:#include \"Point.h\"}",
			"/**",
			" * Author: Oleksandr Bacherikov, chilli",
			" * Date: 2019-05-07",
			" * License: Boost Software License",
			" * Source: https://github.com/AlCash07/ACTL/blob/master/include/actl/geometry/algorithm/intersect/line_convex_polygon.hpp",
			" * Description: Line-convex polygon intersection. The polygon must be ccw and have no collinear points.",
			" * lineHull(line, poly) returns a pair describing the intersection of a line with the polygon:",
			" *  \\begin{itemize*}",
			" *    \\item \\$(-1, -1)\\$ if no collision,",
			" *    \\item \\$(i, -1)\\$ if touching the corner \\$i\\$,",
			" *    \\item \\$(i, i)\\$ if along side \\$(i, i+1)\\$,",
			" *    \\item \\$(i, j)\\$ if crossing sides \\$(i, i+1)\\$ and \\$(j, j+1)\\$.",
			" *  \\end{itemize*}",
			" *  In the last case, if a corner \\$i\\$ is crossed, this is treated as happening on side \\$(i, i+1)\\$.",
			" *  The points are returned in the same order as the line hits the polygon.",
			" * \\texttt{extrVertex} returns the point of a hull with the max projection onto a line.",
			" * Time: O(\\log n)",
			" * Status: stress-tested",
			" */",
			"",
			"#define cmp(i,j) sgn(dir.perp().cross(poly[(i)%n]-poly[(j)%n]))",
			"#define extr(i) cmp(i + 1, i) >= 0 && cmp(i, i - 1 + n) < 0",
			"template <class P> int extrVertex(vector<P>& poly, P dir) {",
			"\tint n = sz(poly), lo = 0, hi = n;",
			"\tif (extr(0)) return 0;",
			"\twhile (lo + 1 < hi) {",
			"\t\tint m = (lo + hi) / 2;",
			"\t\tif (extr(m)) return m;",
			"\t\tint ls = cmp(lo + 1, lo), ms = cmp(m + 1, m);",
			"\t\t(ls < ms || (ls == ms && ls == cmp(lo, m)) ? hi : lo) = m;",
			"\t}",
			"\treturn lo;",
			"}",
			"",
			"#define cmpL(i) sgn(a.cross(poly[i], b))",
			"template <class P>",
			"array<int, 2> lineHull(P a, P b, vector<P>& poly) {",
			"\tint endA = extrVertex(poly, (a - b).perp());",
			"\tint endB = extrVertex(poly, (b - a).perp());",
			"\tif (cmpL(endA) < 0 || cmpL(endB) > 0)",
			"\t\treturn {-1, -1};",
			"\tarray<int, 2> res;",
			"\trep(i,0,2) {",
			"\t\tint lo = endB, hi = endA, n = sz(poly);",
			"\t\twhile ((lo + 1) % n != hi) {",
			"\t\t\tint m = ((lo + hi + (lo < hi ? 0 : n)) / 2) % n;",
			"\t\t\t(cmpL(m) == cmpL(endB) ? lo : hi) = m;",
			"\t\t}",
			"\t\tres[i] = (lo + !cmpL(hi)) % n;",
			"\t\tswap(endA, endB);",
			"\t}",
			"\tif (res[0] == res[1]) return {res[0], -1};",
			"\tif (!cmpL(res[0]) && !cmpL(res[1]))",
			"\t\tswitch ((res[0] - res[1] + sz(poly) + 1) % sz(poly)) {",
			"\t\t\tcase 0: return {res[0], res[0]};",
			"\t\t\tcase 2: return {res[1], res[1]};",
			"\t\t}",
			"\treturn res;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/geometry/PolygonCut.h": {
		"scope": "cpp",
		"prefix": "kactl/geometry/PolygonCut.h",
		"body": [
			"${1:#include \"Point.h\"}",
			"/**",
			" * Author: Ulf Lundstrom",
			" * Date: 2009-03-21",
			" * License: CC0",
			" * Source:",
			" * Description:\\\\",
			"\\begin{minipage}{75mm}",
			" Returns a vector with the vertices of a polygon with everything to the left of the line going from s to e cut away.",
			"\\end{minipage}",
			"\\begin{minipage}{15mm}",
			"\\vspace{-6mm}",
			"\\includegraphics[width=\\textwidth]{content/geometry/PolygonCut}",
			"\\vspace{-6mm}",
			"\\end{minipage}",
			" * Usage:",
			" * \tvector<P> p = ...;",
			" * \tp = polygonCut(p, P(0,0), P(1,0));",
			" * Status: tested but not extensively",
			" */",
			"",
			"typedef Point<double> P;",
			"vector<P> polygonCut(const vector<P>& poly, P s, P e) {",
			"\tvector<P> res;",
			"\trep(i,0,sz(poly)) {",
			"\t\tP cur = poly[i], prev = i ? poly[i-1] : poly.back();",
			"\t\tauto a = s.cross(e, cur), b = s.cross(e, prev);",
			"\t\tif ((a < 0) != (b < 0))",
			"\t\t\tres.push_back(cur + (prev - cur) * (a / (a - b)));",
			"\t\tif (a < 0)",
			"\t\t\tres.push_back(cur);",
			"\t}",
			"\treturn res;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/geometry/linearTransformation.h": {
		"scope": "cpp",
		"prefix": "kactl/geometry/linearTransformation.h",
		"body": [
			"${1:#include \"Point.h\"}",
			"/**",
			" * Author: Per Austrin, Ulf Lundstrom",
			" * Date: 2009-04-09",
			" * License: CC0",
			" * Source:",
			" * Description:\\\\",
			"\\begin{minipage}{75mm}",
			" Apply the linear transformation (translation, rotation and scaling) which takes line p0-p1 to line q0-q1 to point r.",
			"\\end{minipage}",
			"\\begin{minipage}{15mm}",
			"\\vspace{-8mm}",
			"\\includegraphics[width=\\textwidth]{content/geometry/linearTransformation}",
			"\\vspace{-2mm}",
			"\\end{minipage}",
			" * Status: not tested",
			" */",
			"",
			"typedef Point<double> P;",
			"P linearTransformation(const P& p0, const P& p1,",
			"\t\tconst P& q0, const P& q1, const P& r) {",
			"\tP dp = p1-p0, dq = q1-q0, num(dp.cross(dq), dp.dot(dq));",
			"\treturn q0 + P((r-p0).cross(num), (r-p0).dot(num))/dp.dist2();",
			"}",
			"",
			"$0",
		],
	},
	"kactl/geometry/CirclePolygonIntersection.h": {
		"scope": "cpp",
		"prefix": "kactl/geometry/CirclePolygonIntersection.h",
		"body": [
			"${1:#include \"../../content/geometry/Point.h\"}",
			"/**",
			" * Author: chilli, Takanori MAEHARA",
			" * Date: 2019-10-31",
			" * License: CC0",
			" * Source: https://github.com/spaghetti-source/algorithm/blob/master/geometry/_geom.cc#L744",
			" * Description: Returns the area of the intersection of a circle with a",
			" * ccw polygon.",
			" * Time: O(n)",
			" * Status: Tested on GNYR 2019 Gerrymandering, stress-tested",
			" */",
			"",
			"typedef Point<double> P;",
			"#define arg(p, q) atan2(p.cross(q), p.dot(q))",
			"double circlePoly(P c, double r, vector<P> ps) {",
			"\tauto tri = [&](P p, P q) {",
			"\t\tauto r2 = r * r / 2;",
			"\t\tP d = q - p;",
			"\t\tauto a = d.dot(p)/d.dist2(), b = (p.dist2()-r*r)/d.dist2();",
			"\t\tauto det = a * a - b;",
			"\t\tif (det <= 0) return arg(p, q) * r2;",
			"\t\tauto s = max(0., -a-sqrt(det)), t = min(1., -a+sqrt(det));",
			"\t\tif (t < 0 || 1 <= s) return arg(p, q) * r2;",
			"\t\tP u = p + d * s, v = q + d * (t-1);",
			"\t\treturn arg(p,u) * r2 + u.cross(v)/2 + arg(v,q) * r2;",
			"\t};",
			"\tauto sum = 0.0;",
			"\trep(i,0,sz(ps))",
			"\t\tsum += tri(ps[i] - c, ps[(i + 1) % sz(ps)] - c);",
			"\treturn sum;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/geometry/Point3D.h": {
		"scope": "cpp",
		"prefix": "kactl/geometry/Point3D.h",
		"body": [
			"/**",
			" * Author: Ulf Lundstrom with inspiration from tinyKACTL",
			" * Date: 2009-04-14",
			" * License: CC0",
			" * Source:",
			" * Description: Class to handle points in 3D space.",
			" * \tT can be e.g. double or long long.",
			" * Usage:",
			" * Status: tested, except for phi and theta",
			" */",
			"template<class T> struct Point3D {",
			"\ttypedef Point3D P;",
			"\ttypedef const P& R;",
			"\tT x, y, z;",
			"\texplicit Point3D(T x=0, T y=0, T z=0) : x(x), y(y), z(z) {}",
			"\tbool operator<(R p) const {",
			"\t\treturn tie(x, y, z) < tie(p.x, p.y, p.z); }",
			"\tbool operator==(R p) const {",
			"\t\treturn tie(x, y, z) == tie(p.x, p.y, p.z); }",
			"\tP operator+(R p) const { return P(x+p.x, y+p.y, z+p.z); }",
			"\tP operator-(R p) const { return P(x-p.x, y-p.y, z-p.z); }",
			"\tP operator*(T d) const { return P(x*d, y*d, z*d); }",
			"\tP operator/(T d) const { return P(x/d, y/d, z/d); }",
			"\tT dot(R p) const { return x*p.x + y*p.y + z*p.z; }",
			"\tP cross(R p) const {",
			"\t\treturn P(y*p.z - z*p.y, z*p.x - x*p.z, x*p.y - y*p.x);",
			"\t}",
			"\tT dist2() const { return x*x + y*y + z*z; }",
			"\tdouble dist() const { return sqrt((double)dist2()); }",
			"\t//Azimuthal angle (longitude) to x-axis in interval [-pi, pi]",
			"\tdouble phi() const { return atan2(y, x); } ",
			"\t//Zenith angle (latitude) to the z-axis in interval [0, pi]",
			"\tdouble theta() const { return atan2(sqrt(x*x+y*y),z); }",
			"\tP unit() const { return *this/(T)dist(); } //makes dist()=1",
			"\t//returns unit vector normal to *this and p",
			"\tP normal(P p) const { return cross(p).unit(); }",
			"\t//returns point rotated 'angle' radians ccw around axis",
			"\tP rotate(double angle, P axis) const {",
			"\t\tdouble s = sin(angle), c = cos(angle); P u = axis.unit();",
			"\t\treturn u*dot(u)*(1-c) + (*this)*c - cross(u)*s;",
			"\t}",
			"};",
			"",
			"$0",
		],
	},
	"kactl/geometry/ClosestPair.h": {
		"scope": "cpp",
		"prefix": "kactl/geometry/ClosestPair.h",
		"body": [
			"${1:#include \"Point.h\"}",
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2019-04-17",
			" * License: CC0",
			" * Source: https://codeforces.com/blog/entry/58747",
			" * Description: Finds the closest pair of points.",
			" * Time: O(n \\log n)",
			" * Status: stress-tested",
			" */",
			"",
			"typedef Point<ll> P;",
			"pair<P, P> closest(vector<P> v) {",
			"\tassert(sz(v) > 1);",
			"\tset<P> S;",
			"\tsort(all(v), [](P a, P b) { return a.y < b.y; });",
			"\tpair<ll, pair<P, P>> ret{LLONG_MAX, {P(), P()}};",
			"\tint j = 0;",
			"\tfor (P p : v) {",
			"\t\tP d{1 + (ll)sqrt(ret.first), 0};",
			"\t\twhile (v[j].y <= p.y - d.x) S.erase(v[j++]);",
			"\t\tauto lo = S.lower_bound(p - d), hi = S.upper_bound(p + d);",
			"\t\tfor (; lo != hi; ++lo)",
			"\t\t\tret = min(ret, {(*lo - p).dist2(), {*lo, p}});",
			"\t\tS.insert(p);",
			"\t}",
			"\treturn ret.second;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/geometry/lineIntersection.h": {
		"scope": "cpp",
		"prefix": "kactl/geometry/lineIntersection.h",
		"body": [
			"${1:#include \"Point.h\"}",
			"/**",
			" * Author: Victor Lecomte, chilli",
			" * Date: 2019-05-05",
			" * License: CC0",
			" * Source: https://vlecomte.github.io/cp-geo.pdf",
			" * Description:\\\\",
			"\\begin{minipage}{75mm}",
			"If a unique intersection point of the lines going through s1,e1 and s2,e2 exists \\{1, point\\} is returned.",
			"If no intersection point exists \\{0, (0,0)\\} is returned and if infinitely many exists \\{-1, (0,0)\\} is returned.",
			"The wrong position will be returned if P is Point<ll> and the intersection point does not have integer coordinates.",
			"Products of three coordinates are used in intermediate steps so watch out for overflow if using int or ll.",
			"\\end{minipage}",
			"\\begin{minipage}{15mm}",
			"\\includegraphics[width=\\textwidth]{content/geometry/lineIntersection}",
			"\\end{minipage}",
			" * Usage:",
			" * \tauto res = lineInter(s1,e1,s2,e2);",
			" * \tif (res.first == 1)",
			" * \t\tcout << \"intersection point at \" << res.second << endl;",
			" * Status: stress-tested, and tested through half-plane tests",
			" */",
			"",
			"template<class P>",
			"pair<int, P> lineInter(P s1, P e1, P s2, P e2) {",
			"\tauto d = (e1 - s1).cross(e2 - s2);",
			"\tif (d == 0) // if parallel",
			"\t\treturn {-(s1.cross(e1, s2) == 0), P(0, 0)};",
			"\tauto p = s2.cross(e1, e2), q = s2.cross(e2, s1);",
			"\treturn {1, (s1 * p + e1 * q) / d};",
			"}",
			"",
			"$0",
		],
	},
	"kactl/geometry/SegmentIntersection.h": {
		"scope": "cpp",
		"prefix": "kactl/geometry/SegmentIntersection.h",
		"body": [
			"${1:#include \"Point.h\"}",
			"${2:#include \"OnSegment.h\"}",
			"/**",
			" * Author: Victor Lecomte, chilli",
			" * Date: 2019-04-27",
			" * License: CC0",
			" * Source: https://vlecomte.github.io/cp-geo.pdf",
			" * Description:\\\\",
			"\\begin{minipage}{75mm}",
			"If a unique intersection point between the line segments going from s1 to e1 and from s2 to e2 exists then it is returned.",
			"If no intersection point exists an empty vector is returned.",
			"If infinitely many exist a vector with 2 elements is returned, containing the endpoints of the common line segment.",
			"The wrong position will be returned if P is Point<ll> and the intersection point does not have integer coordinates.",
			"Products of three coordinates are used in intermediate steps so watch out for overflow if using int or long long.",
			"\\end{minipage}",
			"\\begin{minipage}{15mm}",
			"\\includegraphics[width=\\textwidth]{content/geometry/SegmentIntersection}",
			"\\end{minipage}",
			" * Usage:",
			" * vector<P> inter = segInter(s1,e1,s2,e2);",
			" * if (sz(inter)==1)",
			" *   cout << \"segments intersect at \" << inter[0] << endl;",
			" * Status: stress-tested, tested on kattis:intersection",
			" */",
			"",
			"template<class P> vector<P> segInter(P a, P b, P c, P d) {",
			"\tauto oa = c.cross(d, a), ob = c.cross(d, b),",
			"\t     oc = a.cross(b, c), od = a.cross(b, d);",
			"\t// Checks if intersection is single non-endpoint point.",
			"\tif (sgn(oa) * sgn(ob) < 0 && sgn(oc) * sgn(od) < 0)",
			"\t\treturn {(a * ob - b * oa) / (ob - oa)};",
			"\tset<P> s;",
			"\tif (onSegment(c, d, a)) s.insert(a);",
			"\tif (onSegment(c, d, b)) s.insert(b);",
			"\tif (onSegment(a, b, c)) s.insert(c);",
			"\tif (onSegment(a, b, d)) s.insert(d);",
			"\treturn {all(s)};",
			"}",
			"",
			"$0",
		],
	},
	"kactl/geometry/PolygonCenter.h": {
		"scope": "cpp",
		"prefix": "kactl/geometry/PolygonCenter.h",
		"body": [
			"${1:#include \"Point.h\"}",
			"/**",
			" * Author: Ulf Lundstrom",
			" * Date: 2009-04-08",
			" * License: CC0",
			" * Source:",
			" * Description: Returns the center of mass for a polygon.",
			" * Time: O(n)",
			" * Status: Tested",
			" */",
			"",
			"typedef Point<double> P;",
			"P polygonCenter(const vector<P>& v) {",
			"\tP res(0, 0); double A = 0;",
			"\tfor (int i = 0, j = sz(v) - 1; i < sz(v); j = i++) {",
			"\t\tres = res + (v[i] + v[j]) * v[j].cross(v[i]);",
			"\t\tA += v[j].cross(v[i]);",
			"\t}",
			"\treturn res / A / 3;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/geometry/CircleIntersection.h": {
		"scope": "cpp",
		"prefix": "kactl/geometry/CircleIntersection.h",
		"body": [
			"${1:#include \"Point.h\"}",
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2015-09-01",
			" * License: CC0",
			" * Description: Computes the pair of points at which two circles intersect.",
			" * Returns false in case of no intersection.",
			" * Status: stress-tested",
			" */",
			"",
			"typedef Point<double> P;",
			"bool circleInter(P a,P b,double r1,double r2,pair<P, P>* out) {",
			"\tif (a == b) { assert(r1 != r2); return false; }",
			"\tP vec = b - a;",
			"\tdouble d2 = vec.dist2(), sum = r1+r2, dif = r1-r2,",
			"\t       p = (d2 + r1*r1 - r2*r2)/(d2*2), h2 = r1*r1 - p*p*d2;",
			"\tif (sum*sum < d2 || dif*dif > d2) return false;",
			"\tP mid = a + vec*p, per = vec.perp() * sqrt(fmax(0, h2) / d2);",
			"\t*out = {mid + per, mid - per};",
			"\treturn true;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/geometry/CircleLine.h": {
		"scope": "cpp",
		"prefix": "kactl/geometry/CircleLine.h",
		"body": [
			"${1:#include \"Point.h\"}",
			"/**",
			" * Author: Victor Lecomte, chilli",
			" * Date: 2019-10-29",
			" * License: CC0",
			" * Source: https://vlecomte.github.io/cp-geo.pdf",
			" * Description: Finds the intersection between a circle and a line.",
			" * Returns a vector of either 0, 1, or 2 intersection points.",
			" * P is intended to be Point<double>.",
			" * Status: unit tested",
			" */",
			"",
			"",
			"template<class P>",
			"vector<P> circleLine(P c, double r, P a, P b) {",
			"\tP ab = b - a, p = a + ab * (c-a).dot(ab) / ab.dist2();",
			"\tdouble s = a.cross(b, c), h2 = r*r - s*s / ab.dist2();",
			"\tif (h2 < 0) return {};",
			"\tif (h2 == 0) return {p};",
			"\tP h = ab.unit() * sqrt(h2);",
			"\treturn {p - h, p + h};",
			"}",
			"",
			"$0",
		],
	},
	"kactl/geometry/ConvexHull.h": {
		"scope": "cpp",
		"prefix": "kactl/geometry/ConvexHull.h",
		"body": [
			"${1:#include \"Point.h\"}",
			"/**",
			" * Author: Stjepan Glavina, chilli",
			" * Date: 2019-05-05",
			" * License: Unlicense",
			" * Source: https://github.com/stjepang/snippets/blob/master/convex_hull.cpp",
			" * Description:",
			"\\\\\\begin{minipage}{75mm}",
			"Returns a vector of the points of the convex hull in counter-clockwise order.",
			"Points on the edge of the hull between two other points are not considered part of the hull.",
			"\\end{minipage}",
			"\\begin{minipage}{15mm}",
			"\\vspace{-6mm}",
			"\\includegraphics[width=\\textwidth]{content/geometry/ConvexHull}",
			"\\vspace{-6mm}",
			"\\end{minipage}",
			" * Time: O(n \\log n)",
			" * Status: stress-tested, tested with kattis:convexhull",
			"*/",
			"",
			"typedef Point<ll> P;",
			"vector<P> convexHull(vector<P> pts) {",
			"\tif (sz(pts) <= 1) return pts;",
			"\tsort(all(pts));",
			"\tvector<P> h(sz(pts)+1);",
			"\tint s = 0, t = 0;",
			"\tfor (int it = 2; it--; s = --t, reverse(all(pts)))",
			"\t\tfor (P p : pts) {",
			"\t\t\twhile (t >= s + 2 && h[t-2].cross(h[t-1], p) <= 0) t--;",
			"\t\t\th[t++] = p;",
			"\t\t}",
			"\treturn {h.begin(), h.begin() + t - (t == 2 && h[0] == h[1])};",
			"}",
			"",
			"$0",
		],
	},
	"kactl/geometry/sideOf.h": {
		"scope": "cpp",
		"prefix": "kactl/geometry/sideOf.h",
		"body": [
			"${1:#include \"Point.h\"}",
			"/**",
			" * Author: Ulf Lundstrom",
			" * Date: 2009-03-21",
			" * License: CC0",
			" * Source:",
			" * Description: Returns where \\$p\\$ is as seen from \\$s\\$ towards \\$e\\$. 1/0/-1 \\$\\Leftrightarrow\\$ left/on line/right.",
			" * If the optional argument \\$eps\\$ is given 0 is returned if \\$p\\$ is within distance \\$eps\\$ from the line.",
			" * P is supposed to be Point<T> where T is e.g. double or long long.",
			" * It uses products in intermediate steps so watch out for overflow if using int or long long.",
			" * Usage:",
			" * \tbool left = sideOf(p1,p2,q)==1;",
			" * Status: tested",
			" */",
			"",
			"template<class P>",
			"int sideOf(P s, P e, P p) { return sgn(s.cross(e, p)); }",
			"",
			"template<class P>",
			"int sideOf(const P& s, const P& e, const P& p, double eps) {",
			"\tauto a = (e-s).cross(p-s);",
			"\tdouble l = (e-s).dist()*eps;",
			"\treturn (a > l) - (a < -l);",
			"}",
			"",
			"$0",
		],
	},
	"kactl/geometry/PolygonUnion.h": {
		"scope": "cpp",
		"prefix": "kactl/geometry/PolygonUnion.h",
		"body": [
			"${1:#include \"Point.h\"}",
			"${2:#include \"sideOf.h\"}",
			"/**",
			" * Author: black_horse2014, chilli",
			" * Date: 2019-10-29",
			" * License: Unknown",
			" * Source: https://codeforces.com/gym/101673/submission/50481926",
			" * Description: Calculates the area of the union of \\$n\\$ polygons (not necessarily",
			" * convex). The points within each polygon must be given in CCW order.",
			" * (Epsilon checks may optionally be added to sideOf/sgn, but shouldn't be needed.)",
			" * Time: \\$O(N^2)\\$, where \\$N\\$ is the total number of points",
			" * Status: stress-tested, Submitted on ECNA 2017 Problem A",
			" */",
			"",
			"typedef Point<double> P;",
			"double rat(P a, P b) { return sgn(b.x) ? a.x/b.x : a.y/b.y; }",
			"double polyUnion(vector<vector<P>>& poly) {",
			"\tdouble ret = 0;",
			"\trep(i,0,sz(poly)) rep(v,0,sz(poly[i])) {",
			"\t\tP A = poly[i][v], B = poly[i][(v + 1) % sz(poly[i])];",
			"\t\tvector<pair<double, int>> segs = {{0, 0}, {1, 0}};",
			"\t\trep(j,0,sz(poly)) if (i != j) {",
			"\t\t\trep(u,0,sz(poly[j])) {",
			"\t\t\t\tP C = poly[j][u], D = poly[j][(u + 1) % sz(poly[j])];",
			"\t\t\t\tint sc = sideOf(A, B, C), sd = sideOf(A, B, D);",
			"\t\t\t\tif (sc != sd) {",
			"\t\t\t\t\tdouble sa = C.cross(D, A), sb = C.cross(D, B);",
			"\t\t\t\t\tif (min(sc, sd) < 0)",
			"\t\t\t\t\t\tsegs.emplace_back(sa / (sa - sb), sgn(sc - sd));",
			"\t\t\t\t} else if (!sc && !sd && j<i && sgn((B-A).dot(D-C))>0){",
			"\t\t\t\t\tsegs.emplace_back(rat(C - A, B - A), 1);",
			"\t\t\t\t\tsegs.emplace_back(rat(D - A, B - A), -1);",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\tsort(all(segs));",
			"\t\tfor (auto& s : segs) s.first = min(max(s.first, 0.0), 1.0);",
			"\t\tdouble sum = 0;",
			"\t\tint cnt = segs[0].second;",
			"\t\trep(j,1,sz(segs)) {",
			"\t\t\tif (!cnt) sum += segs[j].first - segs[j - 1].first;",
			"\t\t\tcnt += segs[j].second;",
			"\t\t}",
			"\t\tret += A.cross(B) * sum;",
			"\t}",
			"\treturn ret / 2;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/geometry/sphericalDistance.h": {
		"scope": "cpp",
		"prefix": "kactl/geometry/sphericalDistance.h",
		"body": [
			"/**",
			" * Author: Ulf Lundstrom",
			" * Date: 2009-04-07",
			" * License: CC0",
			" * Source: My geometric reasoning",
			" * Description: Returns the shortest distance on the sphere with radius radius between the points",
			" * with azimuthal angles (longitude) f1 (\\$\\phi_1\\$) and f2 (\\$\\phi_2\\$) from x axis and zenith angles",
			" * (latitude) t1 (\\$\\theta_1\\$) and t2 (\\$\\theta_2\\$) from z axis (0 = north pole). All angles measured",
			" * in radians. The algorithm starts by converting the spherical coordinates to cartesian coordinates",
			" * so if that is what you have you can use only the two last rows. dx*radius is then the difference",
			" * between the two points in the x direction and d*radius is the total distance between the points.",
			" * Status: tested on kattis:airlinehub",
			" */",
			"double sphericalDistance(double f1, double t1,",
			"\t\tdouble f2, double t2, double radius) {",
			"\tdouble dx = sin(t2)*cos(f2) - sin(t1)*cos(f1);",
			"\tdouble dy = sin(t2)*sin(f2) - sin(t1)*sin(f1);",
			"\tdouble dz = cos(t2) - cos(t1);",
			"\tdouble d = sqrt(dx*dx + dy*dy + dz*dz);",
			"\treturn radius*2*asin(d/2);",
			"}",
			"",
			"$0",
		],
	},
	"kactl/geometry/Point.h": {
		"scope": "cpp",
		"prefix": "kactl/geometry/Point.h",
		"body": [
			"/**",
			" * Author: Ulf Lundstrom",
			" * Date: 2009-02-26",
			" * License: CC0",
			" * Source: My head with inspiration from tinyKACTL",
			" * Description: Class to handle points in the plane.",
			" * \tT can be e.g. double or long long. (Avoid int.)",
			" * Status: Works fine, used a lot",
			" */",
			"template <class T> int sgn(T x) { return (x > 0) - (x < 0); }",
			"template<class T>",
			"struct Point {",
			"\ttypedef Point P;",
			"\tT x, y;",
			"\texplicit Point(T x=0, T y=0) : x(x), y(y) {}",
			"\tbool operator<(P p) const { return tie(x,y) < tie(p.x,p.y); }",
			"\tbool operator==(P p) const { return tie(x,y)==tie(p.x,p.y); }",
			"\tP operator+(P p) const { return P(x+p.x, y+p.y); }",
			"\tP operator-(P p) const { return P(x-p.x, y-p.y); }",
			"\tP operator*(T d) const { return P(x*d, y*d); }",
			"\tP operator/(T d) const { return P(x/d, y/d); }",
			"\tT dot(P p) const { return x*p.x + y*p.y; }",
			"\tT cross(P p) const { return x*p.y - y*p.x; }",
			"\tT cross(P a, P b) const { return (a-*this).cross(b-*this); }",
			"\tT dist2() const { return x*x + y*y; }",
			"\tdouble dist() const { return sqrt((double)dist2()); }",
			"\t// angle to x-axis in interval [-pi, pi]",
			"\tdouble angle() const { return atan2(y, x); }",
			"\tP unit() const { return *this/dist(); } // makes dist()=1",
			"\tP perp() const { return P(-y, x); } // rotates +90 degrees",
			"\tP normal() const { return perp().unit(); }",
			"\t// returns point rotated 'a' radians ccw around the origin",
			"\tP rotate(double a) const {",
			"\t\treturn P(x*cos(a)-y*sin(a),x*sin(a)+y*cos(a)); }",
			"\tfriend ostream& operator<<(ostream& os, P p) {",
			"\t\treturn os << \"(\" << p.x << \",\" << p.y << \")\"; }",
			"};",
			"",
			"$0",
		],
	},
	"kactl/geometry/PolyhedronVolume.h": {
		"scope": "cpp",
		"prefix": "kactl/geometry/PolyhedronVolume.h",
		"body": [
			"/**",
			" * Author: Mattias de Zalenski",
			" * Date: 2002-11-04",
			" * Description: Magic formula for the volume of a polyhedron. Faces should point outwards.",
			" * Status: tested",
			" */",
			"template<class V, class L>",
			"double signedPolyVolume(const V& p, const L& trilist) {",
			"\tdouble v = 0;",
			"\tfor (auto i : trilist) v += p[i.a].cross(p[i.b]).dot(p[i.c]);",
			"\treturn v / 6;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/geometry/3dHull.h": {
		"scope": "cpp",
		"prefix": "kactl/geometry/3dHull.h",
		"body": [
			"${1:#include \"Point3D.h\"}",
			"/**",
			" * Author: Johan Sannemo",
			" * Date: 2017-04-18",
			" * Source: derived from https://gist.github.com/msg555/4963794 by Mark Gordon",
			" * Description: Computes all faces of the 3-dimension hull of a point set.",
			" *  *No four points must be coplanar*, or else random results will be returned.",
			" *  All faces will point outwards.",
			" * Time: O(n^2)",
			" * Status: tested on SPOJ CH3D",
			" */",
			"",
			"typedef Point3D<double> P3;",
			"",
			"struct PR {",
			"\tvoid ins(int x) { (a == -1 ? a : b) = x; }",
			"\tvoid rem(int x) { (a == x ? a : b) = -1; }",
			"\tint cnt() { return (a != -1) + (b != -1); }",
			"\tint a, b;",
			"};",
			"",
			"struct F { P3 q; int a, b, c; };",
			"",
			"vector<F> hull3d(const vector<P3>& A) {",
			"\tassert(sz(A) >= 4);",
			"\tvector<vector<PR>> E(sz(A), vector<PR>(sz(A), {-1, -1}));",
			"#define E(x,y) E[f.x][f.y]",
			"\tvector<F> FS;",
			"\tauto mf = [&](int i, int j, int k, int l) {",
			"\t\tP3 q = (A[j] - A[i]).cross((A[k] - A[i]));",
			"\t\tif (q.dot(A[l]) > q.dot(A[i]))",
			"\t\t\tq = q * -1;",
			"\t\tF f{q, i, j, k};",
			"\t\tE(a,b).ins(k); E(a,c).ins(j); E(b,c).ins(i);",
			"\t\tFS.push_back(f);",
			"\t};",
			"\trep(i,0,4) rep(j,i+1,4) rep(k,j+1,4)",
			"\t\tmf(i, j, k, 6 - i - j - k);",
			"",
			"\trep(i,4,sz(A)) {",
			"\t\trep(j,0,sz(FS)) {",
			"\t\t\tF f = FS[j];",
			"\t\t\tif(f.q.dot(A[i]) > f.q.dot(A[f.a])) {",
			"\t\t\t\tE(a,b).rem(f.c);",
			"\t\t\t\tE(a,c).rem(f.b);",
			"\t\t\t\tE(b,c).rem(f.a);",
			"\t\t\t\tswap(FS[j--], FS.back());",
			"\t\t\t\tFS.pop_back();",
			"\t\t\t}",
			"\t\t}",
			"\t\tint nw = sz(FS);",
			"\t\trep(j,0,nw) {",
			"\t\t\tF f = FS[j];",
			"#define C(a, b, c) if (E(a,b).cnt() != 2) mf(f.a, f.b, i, f.c);",
			"\t\t\tC(a, b, c); C(a, c, b); C(b, c, a);",
			"\t\t}",
			"\t}",
			"\tfor (F& it : FS) if ((A[it.b] - A[it.a]).cross(",
			"\t\tA[it.c] - A[it.a]).dot(it.q) <= 0) swap(it.c, it.b);",
			"\treturn FS;",
			"};",
			"",
			"$0",
		],
	},
	"kactl/geometry/lineDistance.h": {
		"scope": "cpp",
		"prefix": "kactl/geometry/lineDistance.h",
		"body": [
			"${1:#include \"Point.h\"}",
			"/**",
			" * Author: Ulf Lundstrom",
			" * Date: 2009-03-21",
			" * License: CC0",
			" * Source: Basic math",
			" * Description:\\\\",
			"\\begin{minipage}{75mm}",
			"Returns the signed distance between point p and the line containing points a and b.",
			"Positive value on left side and negative on right as seen from a towards b. a==b gives nan.",
			"P is supposed to be Point<T> or Point3D<T> where T is e.g. double or long long.",
			"It uses products in intermediate steps so watch out for overflow if using int or long long.",
			"Using Point3D will always give a non-negative distance. For Point3D, call .dist on the result of the cross product.",
			"\\end{minipage}",
			"\\begin{minipage}{15mm}",
			"\\includegraphics[width=\\textwidth]{content/geometry/lineDistance}",
			"\\end{minipage}",
			" * Status: tested",
			" */",
			"",
			"template<class P>",
			"double lineDist(const P& a, const P& b, const P& p) {",
			"\treturn (double)(b-a).cross(p-a)/(b-a).dist();",
			"}",
			"",
			"$0",
		],
	},
	"kactl/geometry/OnSegment.h": {
		"scope": "cpp",
		"prefix": "kactl/geometry/OnSegment.h",
		"body": [
			"${1:#include \"Point.h\"}",
			"/**",
			" * Author: Victor Lecomte, chilli",
			" * Date: 2019-04-26",
			" * License: CC0",
			" * Source: https://vlecomte.github.io/cp-geo.pdf",
			" * Description: Returns true iff p lies on the line segment from s to e.",
			" * Use \\texttt{(segDist(s,e,p)<=epsilon)} instead when using Point<double>.",
			" * Status:",
			" */",
			"",
			"template<class P> bool onSegment(P s, P e, P p) {",
			"\treturn p.cross(s, e) == 0 && (s - p).dot(e - p) <= 0;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/geometry/FastDelaunay.h": {
		"scope": "cpp",
		"prefix": "kactl/geometry/FastDelaunay.h",
		"body": [
			"${1:#include \"Point.h\"}",
			"/**",
			" * Author: Philippe Legault",
			" * Date: 2016",
			" * License: MIT",
			" * Source: https://github.com/Bathlamos/delaunay-triangulation/",
			" * Description: Fast Delaunay triangulation.",
			" * Each circumcircle contains none of the input points.",
			" * There must be no duplicate points.",
			" * If all points are on a line, no triangles will be returned.",
			" * Should work for doubles as well, though there may be precision issues in 'circ'.",
			" * Returns triangles in order \\{t[0][0], t[0][1], t[0][2], t[1][0], \\dots\\}, all counter-clockwise.",
			" * Time: O(n \\log n)",
			" * Status: stress-tested",
			" */",
			"",
			"typedef Point<ll> P;",
			"typedef struct Quad* Q;",
			"typedef __int128_t lll; // (can be ll if coords are < 2e4)",
			"P arb(LLONG_MAX,LLONG_MAX); // not equal to any other point",
			"",
			"struct Quad {",
			"\tQ rot, o; P p = arb; bool mark;",
			"\tP& F() { return r()->p; }",
			"\tQ& r() { return rot->rot; }",
			"\tQ prev() { return rot->o->rot; }",
			"\tQ next() { return r()->prev(); }",
			"} *H;",
			"",
			"bool circ(P p, P a, P b, P c) { // is p in the circumcircle?",
			"\tlll p2 = p.dist2(), A = a.dist2()-p2,",
			"\t    B = b.dist2()-p2, C = c.dist2()-p2;",
			"\treturn p.cross(a,b)*C + p.cross(b,c)*A + p.cross(c,a)*B > 0;",
			"}",
			"Q makeEdge(P orig, P dest) {",
			"\tQ r = H ? H : new Quad{new Quad{new Quad{new Quad{0}}}};",
			"\tH = r->o; r->r()->r() = r;",
			"\trep(i,0,4) r = r->rot, r->p = arb, r->o = i & 1 ? r : r->r();",
			"\tr->p = orig; r->F() = dest;",
			"\treturn r;",
			"}",
			"void splice(Q a, Q b) {",
			"\tswap(a->o->rot->o, b->o->rot->o); swap(a->o, b->o);",
			"}",
			"Q connect(Q a, Q b) {",
			"\tQ q = makeEdge(a->F(), b->p);",
			"\tsplice(q, a->next());",
			"\tsplice(q->r(), b);",
			"\treturn q;",
			"}",
			"",
			"pair<Q,Q> rec(const vector<P>& s) {",
			"\tif (sz(s) <= 3) {",
			"\t\tQ a = makeEdge(s[0], s[1]), b = makeEdge(s[1], s.back());",
			"\t\tif (sz(s) == 2) return { a, a->r() };",
			"\t\tsplice(a->r(), b);",
			"\t\tauto side = s[0].cross(s[1], s[2]);",
			"\t\tQ c = side ? connect(b, a) : 0;",
			"\t\treturn {side < 0 ? c->r() : a, side < 0 ? c : b->r() };",
			"\t}",
			"",
			"#define H(e) e->F(), e->p",
			"#define valid(e) (e->F().cross(H(base)) > 0)",
			"\tQ A, B, ra, rb;",
			"\tint half = sz(s) / 2;",
			"\ttie(ra, A) = rec({all(s) - half});",
			"\ttie(B, rb) = rec({sz(s) - half + all(s)});",
			"\twhile ((B->p.cross(H(A)) < 0 && (A = A->next())) ||",
			"\t       (A->p.cross(H(B)) > 0 && (B = B->r()->o)));",
			"\tQ base = connect(B->r(), A);",
			"\tif (A->p == ra->p) ra = base->r();",
			"\tif (B->p == rb->p) rb = base;",
			"",
			"#define DEL(e, init, dir) Q e = init->dir; if (valid(e)) \\",
			"\t\twhile (circ(e->dir->F(), H(base), e->F())) { \\",
			"\t\t\tQ t = e->dir; \\",
			"\t\t\tsplice(e, e->prev()); \\",
			"\t\t\tsplice(e->r(), e->r()->prev()); \\",
			"\t\t\te->o = H; H = e; e = t; \\",
			"\t\t}",
			"\tfor (;;) {",
			"\t\tDEL(LC, base->r(), o);  DEL(RC, base, prev());",
			"\t\tif (!valid(LC) && !valid(RC)) break;",
			"\t\tif (!valid(LC) || (valid(RC) && circ(H(RC), H(LC))))",
			"\t\t\tbase = connect(RC, base->r());",
			"\t\telse",
			"\t\t\tbase = connect(base->r(), LC->r());",
			"\t}",
			"\treturn { ra, rb };",
			"}",
			"",
			"vector<P> triangulate(vector<P> pts) {",
			"\tsort(all(pts));  assert(unique(all(pts)) == pts.end());",
			"\tif (sz(pts) < 2) return {};",
			"\tQ e = rec(pts).first;",
			"\tvector<Q> q = {e};",
			"\tint qi = 0;",
			"\twhile (e->o->F().cross(e->F(), e->p) < 0) e = e->o;",
			"#define ADD { Q c = e; do { c->mark = 1; pts.push_back(c->p); \\",
			"\tq.push_back(c->r()); c = c->next(); } while (c != e); }",
			"\tADD; pts.clear();",
			"\twhile (qi < sz(q)) if (!(e = q[qi++])->mark) ADD;",
			"\treturn pts;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/geometry/HullDiameter.h": {
		"scope": "cpp",
		"prefix": "kactl/geometry/HullDiameter.h",
		"body": [
			"${1:#include \"Point.h\"}",
			"/**",
			" * Author: Oleksandr Bacherikov, chilli",
			" * Date: 2019-05-05",
			" * License: Boost Software License",
			" * Source: https://codeforces.com/blog/entry/48868",
			" * Description: Returns the two points with max distance on a convex hull (ccw,",
			" * no duplicate/collinear points).",
			" * Status: stress-tested, tested on kattis:roberthood",
			" * Time: O(n)",
			" */",
			"",
			"typedef Point<ll> P;",
			"array<P, 2> hullDiameter(vector<P> S) {",
			"\tint n = sz(S), j = n < 2 ? 0 : 1;",
			"\tpair<ll, array<P, 2>> res({0, {S[0], S[0]}});",
			"\trep(i,0,j)",
			"\t\tfor (;; j = (j + 1) % n) {",
			"\t\t\tres = max(res, {(S[i] - S[j]).dist2(), {S[i], S[j]}});",
			"\t\t\tif ((S[(j + 1) % n] - S[j]).cross(S[i + 1] - S[i]) >= 0)",
			"\t\t\t\tbreak;",
			"\t\t}",
			"\treturn res.second;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/geometry/kdTree.h": {
		"scope": "cpp",
		"prefix": "kactl/geometry/kdTree.h",
		"body": [
			"${1:#include \"Point.h\"}",
			"/**",
			" * Author: Stanford",
			" * Date: Unknown",
			" * Source: Stanford Notebook",
			" * Description: KD-tree (2d, can be extended to 3d)",
			" * Status: Tested on excellentengineers",
			" */",
			"",
			"typedef long long T;",
			"typedef Point<T> P;",
			"const T INF = numeric_limits<T>::max();",
			"",
			"bool on_x(const P& a, const P& b) { return a.x < b.x; }",
			"bool on_y(const P& a, const P& b) { return a.y < b.y; }",
			"",
			"struct Node {",
			"\tP pt; // if this is a leaf, the single point in it",
			"\tT x0 = INF, x1 = -INF, y0 = INF, y1 = -INF; // bounds",
			"\tNode *first = 0, *second = 0;",
			"",
			"\tT distance(const P& p) { // min squared distance to a point",
			"\t\tT x = (p.x < x0 ? x0 : p.x > x1 ? x1 : p.x);",
			"\t\tT y = (p.y < y0 ? y0 : p.y > y1 ? y1 : p.y);",
			"\t\treturn (P(x,y) - p).dist2();",
			"\t}",
			"",
			"\tNode(vector<P>&& vp) : pt(vp[0]) {",
			"\t\tfor (P p : vp) {",
			"\t\t\tx0 = min(x0, p.x); x1 = max(x1, p.x);",
			"\t\t\ty0 = min(y0, p.y); y1 = max(y1, p.y);",
			"\t\t}",
			"\t\tif (vp.size() > 1) {",
			"\t\t\t// split on x if width >= height (not ideal...)",
			"\t\t\tsort(all(vp), x1 - x0 >= y1 - y0 ? on_x : on_y);",
			"\t\t\t// divide by taking half the array for each child (not",
			"\t\t\t// best performance with many duplicates in the middle)",
			"\t\t\tint half = sz(vp)/2;",
			"\t\t\tfirst = new Node({vp.begin(), vp.begin() + half});",
			"\t\t\tsecond = new Node({vp.begin() + half, vp.end()});",
			"\t\t}",
			"\t}",
			"};",
			"",
			"struct KDTree {",
			"\tNode* root;",
			"\tKDTree(const vector<P>& vp) : root(new Node({all(vp)})) {}",
			"",
			"\tpair<T, P> search(Node *node, const P& p) {",
			"\t\tif (!node->first) {",
			"\t\t\t// uncomment if we should not find the point itself:",
			"\t\t\t// if (p == node->pt) return {INF, P()};",
			"\t\t\treturn make_pair((p - node->pt).dist2(), node->pt);",
			"\t\t}",
			"",
			"\t\tNode *f = node->first, *s = node->second;",
			"\t\tT bfirst = f->distance(p), bsec = s->distance(p);",
			"\t\tif (bfirst > bsec) swap(bsec, bfirst), swap(f, s);",
			"",
			"\t\t// search closest side first, other side if needed",
			"\t\tauto best = search(f, p);",
			"\t\tif (bsec < best.first)",
			"\t\t\tbest = min(best, search(s, p));",
			"\t\treturn best;",
			"\t}",
			"",
			"\t// find nearest point to a point, and its squared distance",
			"\t// (requires an arbitrary operator< for Point)",
			"\tpair<T, P> nearest(const P& p) {",
			"\t\treturn search(root, p);",
			"\t}",
			"};",
			"",
			"$0",
		],
	},
	"kactl/geometry/MinimumEnclosingCircle.h": {
		"scope": "cpp",
		"prefix": "kactl/geometry/MinimumEnclosingCircle.h",
		"body": [
			"${1:#include \"circumcircle.h\"}",
			"/**",
			" * Author: Andrew He, chilli",
			" * Date: 2019-05-07",
			" * License: CC0",
			" * Source: folklore",
			" * Description: Computes the minimum circle that encloses a set of points.",
			" * Time: expected O(n)",
			" * Status: stress-tested",
			" */",
			"",
			"pair<P, double> mec(vector<P> ps) {",
			"\tshuffle(all(ps), mt19937(time(0)));",
			"\tP o = ps[0];",
			"\tdouble r = 0, EPS = 1 + 1e-8;",
			"\trep(i,0,sz(ps)) if ((o - ps[i]).dist() > r * EPS) {",
			"\t\to = ps[i], r = 0;",
			"\t\trep(j,0,i) if ((o - ps[j]).dist() > r * EPS) {",
			"\t\t\to = (ps[i] + ps[j]) / 2;",
			"\t\t\tr = (o - ps[i]).dist();",
			"\t\t\trep(k,0,j) if ((o - ps[k]).dist() > r * EPS) {",
			"\t\t\t\to = ccCenter(ps[i], ps[j], ps[k]);",
			"\t\t\t\tr = (o - ps[i]).dist();",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\treturn {o, r};",
			"}",
			"",
			"$0",
		],
	},
	"kactl/geometry/DelaunayTriangulation.h": {
		"scope": "cpp",
		"prefix": "kactl/geometry/DelaunayTriangulation.h",
		"body": [
			"${1:#include \"Point.h\"}",
			"${2:#include \"3dHull.h\"}",
			"/**",
			" * Author: Mattias de Zalenski",
			" * Date: Unknown",
			" * Source: Geometry in C",
			" * Description: Computes the Delaunay triangulation of a set of points.",
			" *  Each circumcircle contains none of the input points.",
			" *  If any three points are collinear or any four are on the same circle, behavior is undefined.",
			" * Time: O(n^2)",
			" * Status: stress-tested",
			" */",
			"",
			"template<class P, class F>",
			"void delaunay(vector<P>& ps, F trifun) {",
			"\tif (sz(ps) == 3) { int d = (ps[0].cross(ps[1], ps[2]) < 0);",
			"\t\ttrifun(0,1+d,2-d); }",
			"\tvector<P3> p3;",
			"\tfor (P p : ps) p3.emplace_back(p.x, p.y, p.dist2());",
			"\tif (sz(ps) > 3) for(auto t:hull3d(p3)) if ((p3[t.b]-p3[t.a]).",
			"\t\t\tcross(p3[t.c]-p3[t.a]).dot(P3(0,0,1)) < 0)",
			"\t\ttrifun(t.a, t.c, t.b);",
			"}",
			"",
			"$0",
		],
	},
	"kactl/geometry/InsidePolygon.h": {
		"scope": "cpp",
		"prefix": "kactl/geometry/InsidePolygon.h",
		"body": [
			"${1:#include \"Point.h\"}",
			"${2:#include \"OnSegment.h\"}",
			"${3:#include \"SegmentDistance.h\"}",
			"/**",
			" * Author: Victor Lecomte, chilli",
			" * Date: 2019-04-26",
			" * License: CC0",
			" * Source: https://vlecomte.github.io/cp-geo.pdf",
			" * Description: Returns true if p lies within the polygon. If strict is true,",
			" * it returns false for points on the boundary. The algorithm uses",
			" * products in intermediate steps so watch out for overflow.",
			" * Time: O(n)",
			" * Usage:",
			" * vector<P> v = {P{4,4}, P{1,2}, P{2,1}};",
			" * bool in = inPolygon(v, P{3, 3}, false);",
			" * Status: stress-tested and tested on kattis:pointinpolygon",
			" */",
			"",
			"template<class P>",
			"bool inPolygon(vector<P> &p, P a, bool strict = true) {",
			"\tint cnt = 0, n = sz(p);",
			"\trep(i,0,n) {",
			"\t\tP q = p[(i + 1) % n];",
			"\t\tif (onSegment(p[i], q, a)) return !strict;",
			"\t\t//or: if (segDist(p[i], q, a) <= eps) return !strict;",
			"\t\tcnt ^= ((a.y<p[i].y) - (a.y<q.y)) * a.cross(p[i], q) > 0;",
			"\t}",
			"\treturn cnt;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/geometry/PolygonArea.h": {
		"scope": "cpp",
		"prefix": "kactl/geometry/PolygonArea.h",
		"body": [
			"${1:#include \"Point.h\"}",
			"/**",
			" * Author: Ulf Lundstrom",
			" * Date: 2009-03-21",
			" * License: CC0",
			" * Source: tinyKACTL",
			" * Description: Returns twice the signed area of a polygon.",
			" *  Clockwise enumeration gives negative area. Watch out for overflow if using int as T!",
			" * Status: Stress-tested and tested on kattis:polygonarea",
			" */",
			"",
			"template<class T>",
			"T polygonArea2(vector<Point<T>>& v) {",
			"\tT a = v.back().cross(v[0]);",
			"\trep(i,0,sz(v)-1) a += v[i].cross(v[i+1]);",
			"\treturn a;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/geometry/Angle.h": {
		"scope": "cpp",
		"prefix": "kactl/geometry/Angle.h",
		"body": [
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2015-01-31",
			" * License: CC0",
			" * Source: me",
			" * Description: A class for ordering angles (as represented by int points and",
			" *  a number of rotations around the origin). Useful for rotational sweeping.",
			" *  Sometimes also represents points or vectors.",
			" * Usage:",
			" *  vector<Angle> v = {w[0], w[0].t360() ...}; // sorted",
			" *  int j = 0; rep(i,0,n) { while (v[j] < v[i].t180()) ++j; }",
			" *  // sweeps j such that (j-i) represents the number of positively oriented triangles with vertices at 0 and i",
			" * Status: Used, works well",
			" */",
			"struct Angle {",
			"\tint x, y;",
			"\tint t;",
			"\tAngle(int x, int y, int t=0) : x(x), y(y), t(t) {}",
			"\tAngle operator-(Angle b) const { return {x-b.x, y-b.y, t}; }",
			"\tint half() const {",
			"\t\tassert(x || y);",
			"\t\treturn y < 0 || (y == 0 && x < 0);",
			"\t}",
			"\tAngle t90() const { return {-y, x, t + (half() && x >= 0)}; }",
			"\tAngle t180() const { return {-x, -y, t + half()}; }",
			"\tAngle t360() const { return {x, y, t + 1}; }",
			"};",
			"bool operator<(Angle a, Angle b) {",
			"\t// add a.dist2() and b.dist2() to also compare distances",
			"\treturn make_tuple(a.t, a.half(), a.y * (ll)b.x) <",
			"\t       make_tuple(b.t, b.half(), a.x * (ll)b.y);",
			"}",
			"",
			"// Given two points, this calculates the smallest angle between",
			"// them, i.e., the angle that covers the defined line segment.",
			"pair<Angle, Angle> segmentAngles(Angle a, Angle b) {",
			"\tif (b < a) swap(a, b);",
			"\treturn (b < a.t180() ?",
			"\t        make_pair(a, b) : make_pair(b, a.t360()));",
			"}",
			"Angle operator+(Angle a, Angle b) { // point a + vector b",
			"\tAngle r(a.x + b.x, a.y + b.y, a.t);",
			"\tif (a.t180() < r) r.t--;",
			"\treturn r.t180() < a ? r.t360() : r;",
			"}",
			"Angle angleDiff(Angle a, Angle b) { // angle b - angle a",
			"\tint tu = b.t - a.t; a.t = b.t;",
			"\treturn {a.x*b.x + a.y*b.y, a.x*b.y - a.y*b.x, tu - (b < a)};",
			"}",
			"",
			"$0",
		],
	},
	"kactl/geometry/CircleTangents.h": {
		"scope": "cpp",
		"prefix": "kactl/geometry/CircleTangents.h",
		"body": [
			"${1:#include \"Point.h\"}",
			"/**",
			" * Author: Victor Lecomte, chilli",
			" * Date: 2019-10-31",
			" * License: CC0",
			" * Source: https://vlecomte.github.io/cp-geo.pdf",
			" * Description: Finds the external tangents of two circles, or internal if r2 is negated.",
			" * Can return 0, 1, or 2 tangents -- 0 if one circle contains the other (or overlaps it, in the internal case, or if the circles are the same);",
			" * 1 if the circles are tangent to each other (in which case .first = .second and the tangent line is perpendicular to the line between the centers).",
			" * .first and .second give the tangency points at circle 1 and 2 respectively.",
			" * To find the tangents of a circle with a point set r2 to 0.",
			" * Status: tested",
			" */",
			"",
			"template<class P>",
			"vector<pair<P, P>> tangents(P c1, double r1, P c2, double r2) {",
			"\tP d = c2 - c1;",
			"\tdouble dr = r1 - r2, d2 = d.dist2(), h2 = d2 - dr * dr;",
			"\tif (d2 == 0 || h2 < 0)  return {};",
			"\tvector<pair<P, P>> out;",
			"\tfor (double sign : {-1, 1}) {",
			"\t\tP v = (d * dr + d.perp() * sqrt(h2) * sign) / d2;",
			"\t\tout.push_back({c1 + v * r1, c2 + v * r2});",
			"\t}",
			"\tif (h2 == 0) out.pop_back();",
			"\treturn out;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/geometry/LineProjectionReflection.h": {
		"scope": "cpp",
		"prefix": "kactl/geometry/LineProjectionReflection.h",
		"body": [
			"${1:#include \"Point.h\"}",
			"/**",
			" * Author: Victor Lecomte, chilli",
			" * Date: 2019-10-29",
			" * License: CC0",
			" * Source: https://vlecomte.github.io/cp-geo.pdf",
			" * Description: Projects point p onto line ab. Set refl=true to get reflection",
			" * of point p across line ab instead. The wrong point will be returned if P is",
			" * an integer point and the desired point doesn't have integer coordinates.",
			" * Products of three coordinates are used in intermediate steps so watch out",
			" * for overflow.",
			" * Status: stress-tested",
			" */",
			"",
			"template<class P>",
			"P lineProj(P a, P b, P p, bool refl=false) {",
			"\tP v = b - a;",
			"\treturn p - v.perp()*(1+refl)*v.cross(p-a)/v.dist2();",
			"}",
			"",
			"$0",
		],
	},
	"kactl/geometry/ManhattanMST.h": {
		"scope": "cpp",
		"prefix": "kactl/geometry/ManhattanMST.h",
		"body": [
			"${1:#include \"Point.h\"}",
			"/**",
			" * Author: chilli, Takanori MAEHARA",
			" * Date: 2019-11-02",
			" * License: CC0",
			" * Source: https://github.com/spaghetti-source/algorithm/blob/master/geometry/rectilinear_mst.cc",
			" * Description: Given N points, returns up to 4*N edges, which are guaranteed",
			" * to contain a minimum spanning tree for the graph with edge weights w(p, q) =",
			" * |p.x - q.x| + |p.y - q.y|. Edges are in the form (distance, src, dst). Use a",
			" * standard MST algorithm on the result to find the final MST.",
			" * Time: O(N \\log N)",
			" * Status: Stress-tested",
			" */",
			"",
			"typedef Point<int> P;",
			"vector<array<int, 3>> manhattanMST(vector<P> ps) {",
			"\tvi id(sz(ps));",
			"\tiota(all(id), 0);",
			"\tvector<array<int, 3>> edges;",
			"\trep(k,0,4) {",
			"\t\tsort(all(id), [&](int i, int j) {",
			"\t\t     return (ps[i]-ps[j]).x < (ps[j]-ps[i]).y;});",
			"\t\tmap<int, int> sweep;",
			"\t\tfor (int i : id) {",
			"\t\t\tfor (auto it = sweep.lower_bound(-ps[i].y);",
			"\t\t\t\t        it != sweep.end(); sweep.erase(it++)) {",
			"\t\t\t\tint j = it->second;",
			"\t\t\t\tP d = ps[i] - ps[j];",
			"\t\t\t\tif (d.y > d.x) break;",
			"\t\t\t\tedges.push_back({d.y + d.x, i, j});",
			"\t\t\t}",
			"\t\t\tsweep[-ps[i].y] = i;",
			"\t\t}",
			"\t\tfor (P& p : ps) if (k & 1) p.x = -p.x; else swap(p.x, p.y);",
			"\t}",
			"\treturn edges;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/geometry/SegmentDistance.h": {
		"scope": "cpp",
		"prefix": "kactl/geometry/SegmentDistance.h",
		"body": [
			"${1:#include \"Point.h\"}",
			"/**",
			" * Author: Ulf Lundstrom",
			" * Date: 2009-03-21",
			" * License: CC0",
			" * Source:",
			" * Description:\\\\",
			"\\begin{minipage}{75mm}",
			"Returns the shortest distance between point p and the line segment from point s to e.",
			"\\end{minipage}",
			"\\begin{minipage}{15mm}",
			"\\vspace{-10mm}",
			"\\includegraphics[width=\\textwidth]{content/geometry/SegmentDistance}",
			"\\end{minipage}",
			" * Usage: ",
			" * \tPoint<double> a, b(2,2), p(1,1);",
			" * \tbool onSegment = segDist(a,b,p) < 1e-10;",
			" * Status: tested",
			" */",
			"",
			"typedef Point<double> P;",
			"double segDist(P& s, P& e, P& p) {",
			"\tif (s==e) return (p-s).dist();",
			"\tauto d = (e-s).dist2(), t = min(d,max(.0,(p-s).dot(e-s)));",
			"\treturn ((p-s)*d-(e-s)*t).dist()/d;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/geometry/PointInsideHull.h": {
		"scope": "cpp",
		"prefix": "kactl/geometry/PointInsideHull.h",
		"body": [
			"${1:#include \"Point.h\"}",
			"${2:#include \"sideOf.h\"}",
			"${3:#include \"OnSegment.h\"}",
			"/**",
			" * Author: chilli",
			" * Date: 2019-05-17",
			" * License: CC0",
			" * Source: https://github.com/ngthanhtrung23/ACM_Notebook_new",
			" * Description: Determine whether a point t lies inside a convex hull (CCW",
			" * order, with no collinear points). Returns true if point lies within",
			" * the hull. If strict is true, points on the boundary aren't included.",
			" * Usage:",
			" * Status: stress-tested",
			" * Time: O(\\log N)",
			" */",
			"",
			"typedef Point<ll> P;",
			"",
			"bool inHull(const vector<P>& l, P p, bool strict = true) {",
			"\tint a = 1, b = sz(l) - 1, r = !strict;",
			"\tif (sz(l) < 3) return r && onSegment(l[0], l.back(), p);",
			"\tif (sideOf(l[0], l[a], l[b]) > 0) swap(a, b);",
			"\tif (sideOf(l[0], l[a], p) >= r || sideOf(l[0], l[b], p)<= -r)",
			"\t\treturn false;",
			"\twhile (abs(a - b) > 1) {",
			"\t\tint c = (a + b) / 2;",
			"\t\t(sideOf(l[0], l[c], p) > 0 ? b : a) = c;",
			"\t}",
			"\treturn sgn(l[a].cross(l[b], p)) < r;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/geometry/circumcircle.h": {
		"scope": "cpp",
		"prefix": "kactl/geometry/circumcircle.h",
		"body": [
			"${1:#include \"Point.h\"}",
			"/**",
			" * Author: Ulf Lundstrom",
			" * Date: 2009-04-11",
			" * License: CC0",
			" * Source: http://en.wikipedia.org/wiki/Circumcircle",
			" * Description:\\\\",
			"\\begin{minipage}{75mm}",
			"The circumcirle of a triangle is the circle intersecting all three vertices. ccRadius returns the radius of the circle going through points A, B and C and ccCenter returns the center of the same circle.",
			"\\end{minipage}",
			"\\begin{minipage}{15mm}",
			"\\vspace{-2mm}",
			"\\includegraphics[width=\\textwidth]{content/geometry/circumcircle}",
			"\\end{minipage}",
			" * Status: tested",
			" */",
			"",
			"typedef Point<double> P;",
			"double ccRadius(const P& A, const P& B, const P& C) {",
			"\treturn (B-A).dist()*(C-B).dist()*(A-C).dist()/",
			"\t\t\tabs((B-A).cross(C-A))/2;",
			"}",
			"P ccCenter(const P& A, const P& B, const P& C) {",
			"\tP b = C-A, c = B-A;",
			"\treturn A + (b*c.dist2()-c*b.dist2()).perp()/b.cross(c)/2;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/graph/TopoSort.h": {
		"scope": "cpp",
		"prefix": "kactl/graph/TopoSort.h",
		"body": [
			"/**",
			" * Author: Unknown",
			" * Date: 2002-09-13",
			" * Source: predates tinyKACTL",
			" * Description: Topological sorting. Given is an oriented graph.",
			" * Output is an ordering of vertices, such that there are edges only from left to right.",
			" * If there are cycles, the returned list will have size smaller than \\$n\\$ -- nodes reachable",
			" * from cycles will not be returned.",
			" * Time: \\$O(|V|+|E|)\\$",
			" * Status: stress-tested",
			" */",
			"vi topoSort(const vector<vi>& gr) {",
			"\tvi indeg(sz(gr)), q;",
			"\tfor (auto& li : gr) for (int x : li) indeg[x]++;",
			"\trep(i,0,sz(gr)) if (indeg[i] == 0) q.push_back(i);",
			"\trep(j,0,sz(q)) for (int x : gr[q[j]])",
			"\t\tif (--indeg[x] == 0) q.push_back(x);",
			"\treturn q;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/graph/LinkCutTree.h": {
		"scope": "cpp",
		"prefix": "kactl/graph/LinkCutTree.h",
		"body": [
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2016-07-25",
			" * Source: https://github.com/ngthanhtrung23/ACM_Notebook_new/blob/master/DataStructure/LinkCutTree.h",
			" * Description: Represents a forest of unrooted trees. You can add and remove",
			" * edges (as long as the result is still a forest), and check whether",
			" * two nodes are in the same tree.",
			" * Time: All operations take amortized O(\\log N).",
			" * Status: Stress-tested a bit for N <= 20",
			" */",
			"struct Node { // Splay tree. Root's pp contains tree's parent.",
			"\tNode *p = 0, *pp = 0, *c[2];",
			"\tbool flip = 0;",
			"\tNode() { c[0] = c[1] = 0; fix(); }",
			"\tvoid fix() {",
			"\t\tif (c[0]) c[0]->p = this;",
			"\t\tif (c[1]) c[1]->p = this;",
			"\t\t// (+ update sum of subtree elements etc. if wanted)",
			"\t}",
			"\tvoid pushFlip() {",
			"\t\tif (!flip) return;",
			"\t\tflip = 0; swap(c[0], c[1]);",
			"\t\tif (c[0]) c[0]->flip ^= 1;",
			"\t\tif (c[1]) c[1]->flip ^= 1;",
			"\t}",
			"\tint up() { return p ? p->c[1] == this : -1; }",
			"\tvoid rot(int i, int b) {",
			"\t\tint h = i ^ b;",
			"\t\tNode *x = c[i], *y = b == 2 ? x : x->c[h], *z = b ? y : x;",
			"\t\tif ((y->p = p)) p->c[up()] = y;",
			"\t\tc[i] = z->c[i ^ 1];",
			"\t\tif (b < 2) {",
			"\t\t\tx->c[h] = y->c[h ^ 1];",
			"\t\t\ty->c[h ^ 1] = x;",
			"\t\t}",
			"\t\tz->c[i ^ 1] = this;",
			"\t\tfix(); x->fix(); y->fix();",
			"\t\tif (p) p->fix();",
			"\t\tswap(pp, y->pp);",
			"\t}",
			"\tvoid splay() { /// Splay this up to the root. Always finishes without flip set.",
			"\t\tfor (pushFlip(); p; ) {",
			"\t\t\tif (p->p) p->p->pushFlip();",
			"\t\t\tp->pushFlip(); pushFlip();",
			"\t\t\tint c1 = up(), c2 = p->up();",
			"\t\t\tif (c2 == -1) p->rot(c1, 2);",
			"\t\t\telse p->p->rot(c2, c1 != c2);",
			"\t\t}",
			"\t}",
			"\tNode* first() { /// Return the min element of the subtree rooted at this, splayed to the top.",
			"\t\tpushFlip();",
			"\t\treturn c[0] ? c[0]->first() : (splay(), this);",
			"\t}",
			"};",
			"",
			"struct LinkCut {",
			"\tvector<Node> node;",
			"\tLinkCut(int N) : node(N) {}",
			"",
			"\tvoid link(int u, int v) { // add an edge (u, v)",
			"\t\tassert(!connected(u, v));",
			"\t\tmakeRoot(&node[u]);",
			"\t\tnode[u].pp = &node[v];",
			"\t}",
			"\tvoid cut(int u, int v) { // remove an edge (u, v)",
			"\t\tNode *x = &node[u], *top = &node[v];",
			"\t\tmakeRoot(top); x->splay();",
			"\t\tassert(top == (x->pp ?: x->c[0]));",
			"\t\tif (x->pp) x->pp = 0;",
			"\t\telse {",
			"\t\t\tx->c[0] = top->p = 0;",
			"\t\t\tx->fix();",
			"\t\t}",
			"\t}",
			"\tbool connected(int u, int v) { // are u, v in the same tree?",
			"\t\tNode* nu = access(&node[u])->first();",
			"\t\treturn nu == access(&node[v])->first();",
			"\t}",
			"\tvoid makeRoot(Node* u) { /// Move u to root of represented tree.",
			"\t\taccess(u);",
			"\t\tu->splay();",
			"\t\tif(u->c[0]) {",
			"\t\t\tu->c[0]->p = 0;",
			"\t\t\tu->c[0]->flip ^= 1;",
			"\t\t\tu->c[0]->pp = u;",
			"\t\t\tu->c[0] = 0;",
			"\t\t\tu->fix();",
			"\t\t}",
			"\t}",
			"\tNode* access(Node* u) { /// Move u to root aux tree. Return the root of the root aux tree.",
			"\t\tu->splay();",
			"\t\twhile (Node* pp = u->pp) {",
			"\t\t\tpp->splay(); u->pp = 0;",
			"\t\t\tif (pp->c[1]) {",
			"\t\t\t\tpp->c[1]->p = 0; pp->c[1]->pp = pp; }",
			"\t\t\tpp->c[1] = u; pp->fix(); u = pp;",
			"\t\t}",
			"\t\treturn u;",
			"\t}",
			"};",
			"",
			"$0",
		],
	},
	"kactl/graph/MinimumVertexCover.h": {
		"scope": "cpp",
		"prefix": "kactl/graph/MinimumVertexCover.h",
		"body": [
			"${1:#include \"DFSMatching.h\"}",
			"/**",
			" * Author: Johan Sannemo, Simon Lindholm",
			" * Date: 2016-12-15",
			" * License: CC0",
			" * Description: Finds a minimum vertex cover in a bipartite graph.",
			" *  The size is the same as the size of a maximum matching, and",
			" *  the complement is a maximum independent set.",
			" * Status: stress-tested",
			" */",
			"",
			"vi cover(vector<vi>& g, int n, int m) {",
			"\tvi match(m, -1);",
			"\tint res = dfsMatching(g, match);",
			"\tvector<bool> lfound(n, true), seen(m);",
			"\tfor (int it : match) if (it != -1) lfound[it] = false;",
			"\tvi q, cover;",
			"\trep(i,0,n) if (lfound[i]) q.push_back(i);",
			"\twhile (!q.empty()) {",
			"\t\tint i = q.back(); q.pop_back();",
			"\t\tlfound[i] = 1;",
			"\t\tfor (int e : g[i]) if (!seen[e] && match[e] != -1) {",
			"\t\t\tseen[e] = true;",
			"\t\t\tq.push_back(match[e]);",
			"\t\t}",
			"\t}",
			"\trep(i,0,n) if (!lfound[i]) cover.push_back(i);",
			"\trep(i,0,m) if (seen[i]) cover.push_back(n+i);",
			"\tassert(sz(cover) == res);",
			"\treturn cover;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/graph/GomoryHu.h": {
		"scope": "cpp",
		"prefix": "kactl/graph/GomoryHu.h",
		"body": [
			"${1:#include \"PushRelabel.h\"}",
			"/**",
			" * Author: chilli, Takanori MAEHARA",
			" * Date: 2020-04-03",
			" * License: CC0",
			" * Source: https://github.com/spaghetti-source/algorithm/blob/master/graph/gomory_hu_tree.cc#L102",
			" * Description: Given a list of edges representing an undirected flow graph,",
			" * returns edges of the Gomory-Hu tree. The max flow between any pair of",
			" * vertices is given by minimum edge weight along the Gomory-Hu tree path.",
			" * Time: \\$O(V)\\$ Flow Computations",
			" * Status: Tested on CERC 2015 J, stress-tested",
			" *",
			" * Details: The implementation used here is not actually the original",
			" * Gomory-Hu, but Gusfield's simplified version: \"Very simple methods for all",
			" * pairs network flow analysis\". PushRelabel is used here, but any flow",
			" * implementation that supports `leftOfMinCut` also works.",
			" */",
			"",
			"typedef array<ll, 3> Edge;",
			"vector<Edge> gomoryHu(int N, vector<Edge> ed) {",
			"\tvector<Edge> tree;",
			"\tvi par(N);",
			"\trep(i,1,N) {",
			"\t\tPushRelabel D(N); // Dinic also works",
			"\t\tfor (Edge t : ed) D.addEdge(t[0], t[1], t[2], t[2]);",
			"\t\ttree.push_back({i, par[i], D.calc(i, par[i])});",
			"\t\trep(j,i+1,N)",
			"\t\t\tif (par[j] == par[i] && D.leftOfMinCut(j)) par[j] = i;",
			"\t}",
			"\treturn tree;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/graph/hopcroftKarp.h": {
		"scope": "cpp",
		"prefix": "kactl/graph/hopcroftKarp.h",
		"body": [
			"/**",
			" * Author: Chen Xing",
			" * Date: 2009-10-13",
			" * License: CC0",
			" * Source: N/A",
			" * Description: Fast bipartite matching algorithm. Graph \\$g\\$ should be a list",
			" * of neighbors of the left partition, and \\$btoa\\$ should be a vector full of",
			" * -1's of the same size as the right partition. Returns the size of",
			" * the matching. \\$btoa[i]\\$ will be the match for vertex \\$i\\$ on the right side,",
			" * or \\$-1\\$ if it's not matched.",
			" * Usage: vi btoa(m, -1); hopcroftKarp(g, btoa);",
			" * Time: O(\\sqrt{V}E)",
			" * Status: stress-tested by MinimumVertexCover, and tested on oldkattis.adkbipmatch and SPOJ:MATCHING",
			" */",
			"bool dfs(int a, int L, vector<vi>& g, vi& btoa, vi& A, vi& B) {",
			"\tif (A[a] != L) return 0;",
			"\tA[a] = -1;",
			"\tfor (int b : g[a]) if (B[b] == L + 1) {",
			"\t\tB[b] = 0;",
			"\t\tif (btoa[b] == -1 || dfs(btoa[b], L + 1, g, btoa, A, B))",
			"\t\t\treturn btoa[b] = a, 1;",
			"\t}",
			"\treturn 0;",
			"}",
			"",
			"int hopcroftKarp(vector<vi>& g, vi& btoa) {",
			"\tint res = 0;",
			"\tvi A(g.size()), B(btoa.size()), cur, next;",
			"\tfor (;;) {",
			"\t\tfill(all(A), 0);",
			"\t\tfill(all(B), 0);",
			"\t\t/// Find the starting nodes for BFS (i.e. layer 0).",
			"\t\tcur.clear();",
			"\t\tfor (int a : btoa) if(a != -1) A[a] = -1;",
			"\t\trep(a,0,sz(g)) if(A[a] == 0) cur.push_back(a);",
			"\t\t/// Find all layers using bfs.",
			"\t\tfor (int lay = 1;; lay++) {",
			"\t\t\tbool islast = 0;",
			"\t\t\tnext.clear();",
			"\t\t\tfor (int a : cur) for (int b : g[a]) {",
			"\t\t\t\tif (btoa[b] == -1) {",
			"\t\t\t\t\tB[b] = lay;",
			"\t\t\t\t\tislast = 1;",
			"\t\t\t\t}",
			"\t\t\t\telse if (btoa[b] != a && !B[b]) {",
			"\t\t\t\t\tB[b] = lay;",
			"\t\t\t\t\tnext.push_back(btoa[b]);",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t\tif (islast) break;",
			"\t\t\tif (next.empty()) return res;",
			"\t\t\tfor (int a : next) A[a] = lay;",
			"\t\t\tcur.swap(next);",
			"\t\t}",
			"\t\t/// Use DFS to scan for augmenting paths.",
			"\t\trep(a,0,sz(g))",
			"\t\t\tres += dfs(a, 0, g, btoa, A, B);",
			"\t}",
			"}",
			"",
			"$0",
		],
	},
	"kactl/graph/WeightedMatching.h": {
		"scope": "cpp",
		"prefix": "kactl/graph/WeightedMatching.h",
		"body": [
			"/**",
			" * Author: Benjamin Qi, chilli",
			" * Date: 2020-04-04",
			" * License: CC0",
			" * Source: https://github.com/bqi343/USACO/blob/master/Implementations/content/graphs%20(12)/Matching/Hungarian.h",
			" * Description: Given a weighted bipartite graph, matches every node on",
			" * the left with a node on the right such that no",
			" * nodes are in two matchings and the sum of the edge weights is minimal. Takes",
			" * cost[N][M], where cost[i][j] = cost for L[i] to be matched with R[j] and",
			" * returns (min cost, match), where L[i] is matched with",
			" * R[match[i]]. Negate costs for max cost. Requires \\$N \\le M\\$.",
			" * Time: O(N^2M)",
			" * Status: Tested on kattis:cordonbleu, stress-tested",
			" */",
			"pair<int, vi> hungarian(const vector<vi> &a) {",
			"\tif (a.empty()) return {0, {}};",
			"\tint n = sz(a) + 1, m = sz(a[0]) + 1;",
			"\tvi u(n), v(m), p(m), ans(n - 1);",
			"\trep(i,1,n) {",
			"\t\tp[0] = i;",
			"\t\tint j0 = 0; // add \"dummy\" worker 0",
			"\t\tvi dist(m, INT_MAX), pre(m, -1);",
			"\t\tvector<bool> done(m + 1);",
			"\t\tdo { // dijkstra",
			"\t\t\tdone[j0] = true;",
			"\t\t\tint i0 = p[j0], j1, delta = INT_MAX;",
			"\t\t\trep(j,1,m) if (!done[j]) {",
			"\t\t\t\tauto cur = a[i0 - 1][j - 1] - u[i0] - v[j];",
			"\t\t\t\tif (cur < dist[j]) dist[j] = cur, pre[j] = j0;",
			"\t\t\t\tif (dist[j] < delta) delta = dist[j], j1 = j;",
			"\t\t\t}",
			"\t\t\trep(j,0,m) {",
			"\t\t\t\tif (done[j]) u[p[j]] += delta, v[j] -= delta;",
			"\t\t\t\telse dist[j] -= delta;",
			"\t\t\t}",
			"\t\t\tj0 = j1;",
			"\t\t} while (p[j0]);",
			"\t\twhile (j0) { // update alternating path",
			"\t\t\tint j1 = pre[j0];",
			"\t\t\tp[j0] = p[j1], j0 = j1;",
			"\t\t}",
			"\t}",
			"\trep(j,1,m) if (p[j]) ans[p[j] - 1] = j - 1;",
			"\treturn {-v[0], ans}; // min cost",
			"}",
			"",
			"$0",
		],
	},
	"kactl/graph/EdmondsKarp.h": {
		"scope": "cpp",
		"prefix": "kactl/graph/EdmondsKarp.h",
		"body": [
			"/**",
			" * Author: Chen Xing",
			" * Date: 2009-10-13",
			" * License: CC0",
			" * Source: N/A",
			" * Description: Flow algorithm with guaranteed complexity \\$O(VE^2)\\$. To get edge flow values, compare",
			" * capacities before and after, and take the positive values only.",
			" * Status: stress-tested",
			" */",
			"template<class T> T edmondsKarp(vector<unordered_map<int, T>>&",
			"\t\tgraph, int source, int sink) {",
			"\tassert(source != sink);",
			"\tT flow = 0;",
			"\tvi par(sz(graph)), q = par;",
			"",
			"\tfor (;;) {",
			"\t\tfill(all(par), -1);",
			"\t\tpar[source] = 0;",
			"\t\tint ptr = 1;",
			"\t\tq[0] = source;",
			"",
			"\t\trep(i,0,ptr) {",
			"\t\t\tint x = q[i];",
			"\t\t\tfor (auto e : graph[x]) {",
			"\t\t\t\tif (par[e.first] == -1 && e.second > 0) {",
			"\t\t\t\t\tpar[e.first] = x;",
			"\t\t\t\t\tq[ptr++] = e.first;",
			"\t\t\t\t\tif (e.first == sink) goto out;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn flow;",
			"out:",
			"\t\tT inc = numeric_limits<T>::max();",
			"\t\tfor (int y = sink; y != source; y = par[y])",
			"\t\t\tinc = min(inc, graph[par[y]][y]);",
			"",
			"\t\tflow += inc;",
			"\t\tfor (int y = sink; y != source; y = par[y]) {",
			"\t\t\tint p = par[y];",
			"\t\t\tif ((graph[p][y] -= inc) <= 0) graph[p].erase(y);",
			"\t\t\tgraph[y][p] += inc;",
			"\t\t}",
			"\t}",
			"}",
			"",
			"$0",
		],
	},
	"kactl/graph/GeneralMatching.h": {
		"scope": "cpp",
		"prefix": "kactl/graph/GeneralMatching.h",
		"body": [
			"${1:#include \"../numerical/MatrixInverse-mod.h\"}",
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2016-12-09",
			" * License: CC0",
			" * Source: http://www.mimuw.edu.pl/~mucha/pub/mucha_sankowski_focs04.pdf",
			" * Description: Matching for general graphs.",
			" * Fails with probability \\$N / mod\\$.",
			" * Time: O(N^3)",
			" * Status: not very well tested",
			" */",
			"",
			"vector<pii> generalMatching(int N, vector<pii>& ed) {",
			"\tvector<vector<ll>> mat(N, vector<ll>(N)), A;",
			"\tfor (pii pa : ed) {",
			"\t\tint a = pa.first, b = pa.second, r = rand() % mod;",
			"\t\tmat[a][b] = r, mat[b][a] = (mod - r) % mod;",
			"\t}",
			"",
			"\tint r = matInv(A = mat), M = 2*N - r, fi, fj;",
			"\tassert(r % 2 == 0);",
			"",
			"\tif (M != N) do {",
			"\t\tmat.resize(M, vector<ll>(M));",
			"\t\trep(i,0,N) {",
			"\t\t\tmat[i].resize(M);",
			"\t\t\trep(j,N,M) {",
			"\t\t\t\tint r = rand() % mod;",
			"\t\t\t\tmat[i][j] = r, mat[j][i] = (mod - r) % mod;",
			"\t\t\t}",
			"\t\t}",
			"\t} while (matInv(A = mat) != M);",
			"",
			"\tvi has(M, 1); vector<pii> ret;",
			"\trep(it,0,M/2) {",
			"\t\trep(i,0,M) if (has[i])",
			"\t\t\trep(j,i+1,M) if (A[i][j] && mat[i][j]) {",
			"\t\t\t\tfi = i; fj = j; goto done;",
			"\t\t} assert(0); done:",
			"\t\tif (fj < N) ret.emplace_back(fi, fj);",
			"\t\thas[fi] = has[fj] = 0;",
			"\t\trep(sw,0,2) {",
			"\t\t\tll a = modpow(A[fi][fj], mod-2);",
			"\t\t\trep(i,0,M) if (has[i] && A[i][fj]) {",
			"\t\t\t\tll b = A[i][fj] * a % mod;",
			"\t\t\t\trep(j,0,M) A[i][j] = (A[i][j] - A[fi][j] * b) % mod;",
			"\t\t\t}",
			"\t\t\tswap(fi,fj);",
			"\t\t}",
			"\t}",
			"\treturn ret;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/graph/EdgeColoring.h": {
		"scope": "cpp",
		"prefix": "kactl/graph/EdgeColoring.h",
		"body": [
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2020-10-12",
			" * License: CC0",
			" * Source: https://en.wikipedia.org/wiki/Misra_%26_Gries_edge_coloring_algorithm",
			" * https://codeforces.com/blog/entry/75431 for the note about bipartite graphs.",
			" * Description: Given a simple, undirected graph with max degree \\$D\\$, computes a",
			" * \\$(D + 1)\\$-coloring of the edges such that no neighboring edges share a color.",
			" * (\\$D\\$-coloring is NP-hard, but can be done for bipartite graphs by repeated matchings of",
			" * max-degree nodes.)",
			" * Time: O(NM)",
			" * Status: stress-tested, tested on kattis:gamescheduling",
			" */",
			"vi edgeColoring(int N, vector<pii> eds) {",
			"\tvi cc(N + 1), ret(sz(eds)), fan(N), free(N), loc;",
			"\tfor (pii e : eds) ++cc[e.first], ++cc[e.second];",
			"\tint u, v, ncols = *max_element(all(cc)) + 1;",
			"\tvector<vi> adj(N, vi(ncols, -1));",
			"\tfor (pii e : eds) {",
			"\t\ttie(u, v) = e;",
			"\t\tfan[0] = v;",
			"\t\tloc.assign(ncols, 0);",
			"\t\tint at = u, end = u, d, c = free[u], ind = 0, i = 0;",
			"\t\twhile (d = free[v], !loc[d] && (v = adj[u][d]) != -1)",
			"\t\t\tloc[d] = ++ind, cc[ind] = d, fan[ind] = v;",
			"\t\tcc[loc[d]] = c;",
			"\t\tfor (int cd = d; at != -1; cd ^= c ^ d, at = adj[at][cd])",
			"\t\t\tswap(adj[at][cd], adj[end = at][cd ^ c ^ d]);",
			"\t\twhile (adj[fan[i]][d] != -1) {",
			"\t\t\tint left = fan[i], right = fan[++i], e = cc[i];",
			"\t\t\tadj[u][e] = left;",
			"\t\t\tadj[left][e] = u;",
			"\t\t\tadj[right][e] = -1;",
			"\t\t\tfree[right] = e;",
			"\t\t}",
			"\t\tadj[u][d] = fan[i];",
			"\t\tadj[fan[i]][d] = u;",
			"\t\tfor (int y : {fan[0], u, end})",
			"\t\t\tfor (int& z = free[y] = 0; adj[y][z] != -1; z++);",
			"\t}",
			"\trep(i,0,sz(eds))",
			"\t\tfor (tie(u, v) = eds[i]; adj[u][ret[i]] != v;) ++ret[i];",
			"\treturn ret;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/graph/Dinic.h": {
		"scope": "cpp",
		"prefix": "kactl/graph/Dinic.h",
		"body": [
			"/**",
			" * Author: chilli",
			" * Date: 2019-04-26",
			" * License: CC0",
			" * Source: https://cp-algorithms.com/graph/dinic.html",
			" * Description: Flow algorithm with complexity \\$O(VE\\log U)\\$ where \\$U = \\max |\\text{cap}|\\$.",
			" * \\$O(\\min(E^{1/2}, V^{2/3})E)\\$ if \\$U = 1\\$; \\$O(\\sqrt{V}E)\\$ for bipartite matching.",
			" * Status: Tested on SPOJ FASTFLOW and SPOJ MATCHING, stress-tested",
			" */",
			"struct Dinic {",
			"\tstruct Edge {",
			"\t\tint to, rev;",
			"\t\tll c, oc;",
			"\t\tll flow() { return max(oc - c, 0LL); } // if you need flows",
			"\t};",
			"\tvi lvl, ptr, q;",
			"\tvector<vector<Edge>> adj;",
			"\tDinic(int n) : lvl(n), ptr(n), q(n), adj(n) {}",
			"\tvoid addEdge(int a, int b, ll c, ll rcap = 0) {",
			"\t\tadj[a].push_back({b, sz(adj[b]), c, c});",
			"\t\tadj[b].push_back({a, sz(adj[a]) - 1, rcap, rcap});",
			"\t}",
			"\tll dfs(int v, int t, ll f) {",
			"\t\tif (v == t || !f) return f;",
			"\t\tfor (int& i = ptr[v]; i < sz(adj[v]); i++) {",
			"\t\t\tEdge& e = adj[v][i];",
			"\t\t\tif (lvl[e.to] == lvl[v] + 1)",
			"\t\t\t\tif (ll p = dfs(e.to, t, min(f, e.c))) {",
			"\t\t\t\t\te.c -= p, adj[e.to][e.rev].c += p;",
			"\t\t\t\t\treturn p;",
			"\t\t\t\t}",
			"\t\t}",
			"\t\treturn 0;",
			"\t}",
			"\tll calc(int s, int t) {",
			"\t\tll flow = 0; q[0] = s;",
			"\t\trep(L,0,31) do { // 'int L=30' maybe faster for random data",
			"\t\t\tlvl = ptr = vi(sz(q));",
			"\t\t\tint qi = 0, qe = lvl[s] = 1;",
			"\t\t\twhile (qi < qe && !lvl[t]) {",
			"\t\t\t\tint v = q[qi++];",
			"\t\t\t\tfor (Edge e : adj[v])",
			"\t\t\t\t\tif (!lvl[e.to] && e.c >> (30 - L))",
			"\t\t\t\t\t\tq[qe++] = e.to, lvl[e.to] = lvl[v] + 1;",
			"\t\t\t}",
			"\t\t\twhile (ll p = dfs(s, t, LLONG_MAX)) flow += p;",
			"\t\t} while (lvl[t]);",
			"\t\treturn flow;",
			"\t}",
			"\tbool leftOfMinCut(int a) { return lvl[a] != 0; }",
			"};",
			"",
			"$0",
		],
	},
	"kactl/graph/MinCut.h": {
		"scope": "cpp",
		"prefix": "kactl/graph/MinCut.h",
		"body": [
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2015-05-13",
			" * Source: Wikipedia",
			" * Description: After running max-flow, the left side of a min-cut from \\$s\\$ to \\$t\\$ is given",
			" * by all vertices reachable from \\$s\\$, only traversing edges with positive residual capacity.",
			" * Status: works",
			" */",
			"",
			"$0",
		],
	},
	"kactl/graph/MinCostMaxFlow.h": {
		"scope": "cpp",
		"prefix": "kactl/graph/MinCostMaxFlow.h",
		"body": [
			"/**",
			" * Author: Stanford",
			" * Date: Unknown",
			" * Source: Stanford Notebook",
			" * Description: Min-cost max-flow.",
			" *  If costs can be negative, call setpi before maxflow, but note that negative cost cycles are not supported.",
			" *  To obtain the actual flow, look at positive values only.",
			" * Status: Tested on kattis:mincostmaxflow, stress-tested against another implementation",
			" * Time: \\$O(F E \\log(V))\\$ where F is max flow. \\$O(VE)\\$ for setpi.",
			" */",
			"// #include <bits/extc++.h> /// include-line, keep-include",
			"",
			"const ll INF = numeric_limits<ll>::max() / 4;",
			"",
			"struct MCMF {",
			"\tstruct edge {",
			"\t\tint from, to, rev;",
			"\t\tll cap, cost, flow;",
			"\t};",
			"\tint N;",
			"\tvector<vector<edge>> ed;",
			"\tvi seen;",
			"\tvector<ll> dist, pi;",
			"\tvector<edge*> par;",
			"",
			"\tMCMF(int N) : N(N), ed(N), seen(N), dist(N), pi(N), par(N) {}",
			"",
			"\tvoid addEdge(int from, int to, ll cap, ll cost) {",
			"\t\tif (from == to) return;",
			"\t\ted[from].push_back(edge{ from,to,sz(ed[to]),cap,cost,0 });",
			"\t\ted[to].push_back(edge{ to,from,sz(ed[from])-1,0,-cost,0 });",
			"\t}",
			"",
			"\tvoid path(int s) {",
			"\t\tfill(all(seen), 0);",
			"\t\tfill(all(dist), INF);",
			"\t\tdist[s] = 0; ll di;",
			"",
			"\t\t__gnu_pbds::priority_queue<pair<ll, int>> q;",
			"\t\tvector<decltype(q)::point_iterator> its(N);",
			"\t\tq.push({ 0, s });",
			"",
			"\t\twhile (!q.empty()) {",
			"\t\t\ts = q.top().second; q.pop();",
			"\t\t\tseen[s] = 1; di = dist[s] + pi[s];",
			"\t\t\tfor (edge& e : ed[s]) if (!seen[e.to]) {",
			"\t\t\t\tll val = di - pi[e.to] + e.cost;",
			"\t\t\t\tif (e.cap - e.flow > 0 && val < dist[e.to]) {",
			"\t\t\t\t\tdist[e.to] = val;",
			"\t\t\t\t\tpar[e.to] = &e;",
			"\t\t\t\t\tif (its[e.to] == q.end())",
			"\t\t\t\t\t\tits[e.to] = q.push({ -dist[e.to], e.to });",
			"\t\t\t\t\telse",
			"\t\t\t\t\t\tq.modify(its[e.to], { -dist[e.to], e.to });",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\trep(i,0,N) pi[i] = min(pi[i] + dist[i], INF);",
			"\t}",
			"",
			"\tpair<ll, ll> maxflow(int s, int t) {",
			"\t\tll totflow = 0, totcost = 0;",
			"\t\twhile (path(s), seen[t]) {",
			"\t\t\tll fl = INF;",
			"\t\t\tfor (edge* x = par[t]; x; x = par[x->from])",
			"\t\t\t\tfl = min(fl, x->cap - x->flow);",
			"",
			"\t\t\ttotflow += fl;",
			"\t\t\tfor (edge* x = par[t]; x; x = par[x->from]) {",
			"\t\t\t\tx->flow += fl;",
			"\t\t\t\ted[x->to][x->rev].flow -= fl;",
			"\t\t\t}",
			"\t\t}",
			"\t\trep(i,0,N) for(edge& e : ed[i]) totcost += e.cost * e.flow;",
			"\t\treturn {totflow, totcost/2};",
			"\t}",
			"",
			"\t// If some costs can be negative, call this before maxflow:",
			"\tvoid setpi(int s) { // (otherwise, leave this out)",
			"\t\tfill(all(pi), INF); pi[s] = 0;",
			"\t\tint it = N, ch = 1; ll v;",
			"\t\twhile (ch-- && it--)",
			"\t\t\trep(i,0,N) if (pi[i] != INF)",
			"\t\t\t  for (edge& e : ed[i]) if (e.cap)",
			"\t\t\t\t  if ((v = pi[i] + e.cost) < pi[e.to])",
			"\t\t\t\t\t  pi[e.to] = v, ch = 1;",
			"\t\tassert(it >= 0); // negative cost cycle",
			"\t}",
			"};",
			"",
			"$0",
		],
	},
	"kactl/graph/SCC.h": {
		"scope": "cpp",
		"prefix": "kactl/graph/SCC.h",
		"body": [
			"/**",
			" * Author: Lukas Polacek",
			" * Date: 2009-10-28",
			" * License: CC0",
			" * Source: Czech graph algorithms book, by Demel. (Tarjan's algorithm)",
			" * Description: Finds strongly connected components in a",
			" * directed graph. If vertices \\$u, v\\$ belong to the same component,",
			" * we can reach \\$u\\$ from \\$v\\$ and vice versa.",
			" * Usage: scc(graph, [\\&](vi\\& v) { ... }) visits all components",
			" * in reverse topological order. comp[i] holds the component",
			" * index of a node (a component only has edges to components with",
			" * lower index). ncomps will contain the number of components.",
			" * Time: O(E + V)",
			" * Status: Bruteforce-tested for N <= 5",
			" */",
			"vi val, comp, z, cont;",
			"int Time, ncomps;",
			"template<class G, class F> int dfs(int j, G& g, F& f) {",
			"\tint low = val[j] = ++Time, x; z.push_back(j);",
			"\tfor (auto e : g[j]) if (comp[e] < 0)",
			"\t\tlow = min(low, val[e] ?: dfs(e,g,f));",
			"",
			"\tif (low == val[j]) {",
			"\t\tdo {",
			"\t\t\tx = z.back(); z.pop_back();",
			"\t\t\tcomp[x] = ncomps;",
			"\t\t\tcont.push_back(x);",
			"\t\t} while (x != j);",
			"\t\tf(cont); cont.clear();",
			"\t\tncomps++;",
			"\t}",
			"\treturn val[j] = low;",
			"}",
			"template<class G, class F> void scc(G& g, F f) {",
			"\tint n = sz(g);",
			"\tval.assign(n, 0); comp.assign(n, -1);",
			"\tTime = ncomps = 0;",
			"\trep(i,0,n) if (comp[i] < 0) dfs(i, g, f);",
			"}",
			"",
			"$0",
		],
	},
	"kactl/graph/GlobalMinCut.h": {
		"scope": "cpp",
		"prefix": "kactl/graph/GlobalMinCut.h",
		"body": [
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2021-01-09",
			" * License: CC0",
			" * Source: https://en.wikipedia.org/wiki/Stoer%E2%80%93Wagner_algorithm",
			" * Description: Find a global minimum cut in an undirected graph, as represented by an adjacency matrix.",
			" * Time: O(V^3)",
			" * Status: Stress-tested together with GomoryHu",
			" */",
			"pair<int, vi> globalMinCut(vector<vi> mat) {",
			"\tpair<int, vi> best = {INT_MAX, {}};",
			"\tint n = sz(mat);",
			"\tvector<vi> co(n);",
			"\trep(i,0,n) co[i] = {i};",
			"\trep(ph,1,n) {",
			"\t\tvi w = mat[0];",
			"\t\tsize_t s = 0, t = 0;",
			"\t\trep(it,0,n-ph) { // O(V^2) -> O(E log V) with prio. queue",
			"\t\t\tw[t] = INT_MIN;",
			"\t\t\ts = t, t = max_element(all(w)) - w.begin();",
			"\t\t\trep(i,0,n) w[i] += mat[t][i];",
			"\t\t}",
			"\t\tbest = min(best, {w[t] - mat[t][t], co[t]});",
			"\t\tco[s].insert(co[s].end(), all(co[t]));",
			"\t\trep(i,0,n) mat[s][i] += mat[t][i];",
			"\t\trep(i,0,n) mat[i][s] = mat[s][i];",
			"\t\tmat[0][t] = INT_MIN;",
			"\t}",
			"\treturn best;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/graph/MaximalCliques.h": {
		"scope": "cpp",
		"prefix": "kactl/graph/MaximalCliques.h",
		"body": [
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2018-07-18",
			" * License: CC0",
			" * Source: https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm",
			" * Description: Runs a callback for all maximal cliques in a graph (given as a",
			" * symmetric bitset matrix; self-edges not allowed). Callback is given a bitset",
			" * representing the maximal clique.",
			" * Time: O(3^{n/3}), much faster for sparse graphs",
			" * Status: stress-tested",
			" */",
			"/// Possible optimization: on the top-most",
			"/// recursion level, ignore 'cands', and go through nodes in order of increasing",
			"/// degree, where degrees go down as nodes are removed.",
			"/// (mostly irrelevant given MaximumClique)",
			"",
			"typedef bitset<128> B;",
			"template<class F>",
			"void cliques(vector<B>& eds, F f, B P = ~B(), B X={}, B R={}) {",
			"\tif (!P.any()) { if (!X.any()) f(R); return; }",
			"\tauto q = (P | X)._Find_first();",
			"\tauto cands = P & ~eds[q];",
			"\trep(i,0,sz(eds)) if (cands[i]) {",
			"\t\tR[i] = 1;",
			"\t\tcliques(eds, f, P & eds[i], X & eds[i], R);",
			"\t\tR[i] = P[i] = 0; X[i] = 1;",
			"\t}",
			"}",
			"",
			"$0",
		],
	},
	"kactl/graph/DFSMatching.h": {
		"scope": "cpp",
		"prefix": "kactl/graph/DFSMatching.h",
		"body": [
			"/**",
			" * Author: Lukas Polacek",
			" * Date: 2009-10-28",
			" * License: CC0",
			" * Source:",
			" * Description: Simple bipartite matching algorithm. Graph \\$g\\$ should be a list",
			" * of neighbors of the left partition, and \\$btoa\\$ should be a vector full of",
			" * -1's of the same size as the right partition. Returns the size of",
			" * the matching. \\$btoa[i]\\$ will be the match for vertex \\$i\\$ on the right side,",
			" * or \\$-1\\$ if it's not matched.",
			" * Time: O(VE)",
			" * Usage: vi btoa(m, -1); dfsMatching(g, btoa);",
			" * Status: works",
			" */",
			"bool find(int j, vector<vi>& g, vi& btoa, vi& vis) {",
			"\tif (btoa[j] == -1) return 1;",
			"\tvis[j] = 1; int di = btoa[j];",
			"\tfor (int e : g[di])",
			"\t\tif (!vis[e] && find(e, g, btoa, vis)) {",
			"\t\t\tbtoa[e] = di;",
			"\t\t\treturn 1;",
			"\t\t}",
			"\treturn 0;",
			"}",
			"int dfsMatching(vector<vi>& g, vi& btoa) {",
			"\tvi vis;",
			"\trep(i,0,sz(g)) {",
			"\t\tvis.assign(sz(btoa), 0);",
			"\t\tfor (int j : g[i])",
			"\t\t\tif (find(j, g, btoa, vis)) {",
			"\t\t\t\tbtoa[j] = i;",
			"\t\t\t\tbreak;",
			"\t\t\t}",
			"\t}",
			"\treturn sz(btoa) - (int)count(all(btoa), -1);",
			"}",
			"",
			"$0",
		],
	},
	"kactl/graph/CompressTree.h": {
		"scope": "cpp",
		"prefix": "kactl/graph/CompressTree.h",
		"body": [
			"${1:#include \"LCA.h\"}",
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2016-01-14",
			" * License: CC0",
			" * Description: Given a rooted tree and a subset S of nodes, compute the minimal",
			" * subtree that contains all the nodes by adding all (at most \\$|S|-1\\$)",
			" * pairwise LCA's and compressing edges.",
			" * Returns a list of (par, orig\\_index) representing a tree rooted at 0.",
			" * The root points to itself.",
			" * Time: \\$O(|S| \\log |S|)\\$",
			" * Status: Tested at CodeForces",
			" */",
			"",
			"typedef vector<pair<int, int>> vpi;",
			"vpi compressTree(LCA& lca, const vi& subset) {",
			"\tstatic vi rev; rev.resize(sz(lca.time));",
			"\tvi li = subset, &T = lca.time;",
			"\tauto cmp = [&](int a, int b) { return T[a] < T[b]; };",
			"\tsort(all(li), cmp);",
			"\tint m = sz(li)-1;",
			"\trep(i,0,m) {",
			"\t\tint a = li[i], b = li[i+1];",
			"\t\tli.push_back(lca.lca(a, b));",
			"\t}",
			"\tsort(all(li), cmp);",
			"\tli.erase(unique(all(li)), li.end());",
			"\trep(i,0,sz(li)) rev[li[i]] = i;",
			"\tvpi ret = {pii(0, li[0])};",
			"\trep(i,0,sz(li)-1) {",
			"\t\tint a = li[i], b = li[i+1];",
			"\t\tret.emplace_back(rev[lca.lca(a, b)], b);",
			"\t}",
			"\treturn ret;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/graph/2sat.h": {
		"scope": "cpp",
		"prefix": "kactl/graph/2sat.h",
		"body": [
			"/**",
			" * Author: Emil Lenngren, Simon Lindholm",
			" * Date: 2011-11-29",
			" * License: CC0",
			" * Source: folklore",
			" * Description: Calculates a valid assignment to boolean variables a, b, c,... to a 2-SAT problem,",
			" * so that an expression of the type \\$(a||b)\\&\\&(!a||c)\\&\\&(d||!b)\\&\\&...\\$",
			" * becomes true, or reports that it is unsatisfiable.",
			" * Negated variables are represented by bit-inversions (\\texttt{\\tilde{}x}).",
			" * Usage:",
			" *  TwoSat ts(number of boolean variables);",
			" *  ts.either(0, \\tilde3); // Var 0 is true or var 3 is false",
			" *  ts.setValue(2); // Var 2 is true",
			" *  ts.atMostOne({0,\\tilde1,2}); // <= 1 of vars 0, \\tilde1 and 2 are true",
			" *  ts.solve(); // Returns true iff it is solvable",
			" *  ts.values[0..N-1] holds the assigned values to the vars",
			" * Time: O(N+E), where N is the number of boolean variables, and E is the number of clauses.",
			" * Status: stress-tested",
			" */",
			"struct TwoSat {",
			"\tint N;",
			"\tvector<vi> gr;",
			"\tvi values; // 0 = false, 1 = true",
			"",
			"\tTwoSat(int n = 0) : N(n), gr(2*n) {}",
			"",
			"\tint addVar() { // (optional)",
			"\t\tgr.emplace_back();",
			"\t\tgr.emplace_back();",
			"\t\treturn N++;",
			"\t}",
			"",
			"\tvoid either(int f, int j) {",
			"\t\tf = max(2*f, -1-2*f);",
			"\t\tj = max(2*j, -1-2*j);",
			"\t\tgr[f].push_back(j^1);",
			"\t\tgr[j].push_back(f^1);",
			"\t}",
			"\tvoid setValue(int x) { either(x, x); }",
			"",
			"\tvoid atMostOne(const vi& li) { // (optional)",
			"\t\tif (sz(li) <= 1) return;",
			"\t\tint cur = ~li[0];",
			"\t\trep(i,2,sz(li)) {",
			"\t\t\tint next = addVar();",
			"\t\t\teither(cur, ~li[i]);",
			"\t\t\teither(cur, next);",
			"\t\t\teither(~li[i], next);",
			"\t\t\tcur = ~next;",
			"\t\t}",
			"\t\teither(cur, ~li[1]);",
			"\t}",
			"",
			"\tvi val, comp, z; int time = 0;",
			"\tint dfs(int i) {",
			"\t\tint low = val[i] = ++time, x; z.push_back(i);",
			"\t\tfor(int e : gr[i]) if (!comp[e])",
			"\t\t\tlow = min(low, val[e] ?: dfs(e));",
			"\t\tif (low == val[i]) do {",
			"\t\t\tx = z.back(); z.pop_back();",
			"\t\t\tcomp[x] = low;",
			"\t\t\tif (values[x>>1] == -1)",
			"\t\t\t\tvalues[x>>1] = x&1;",
			"\t\t} while (x != i);",
			"\t\treturn val[i] = low;",
			"\t}",
			"",
			"\tbool solve() {",
			"\t\tvalues.assign(N, -1);",
			"\t\tval.assign(2*N, 0); comp = val;",
			"\t\trep(i,0,2*N) if (!comp[i]) dfs(i);",
			"\t\trep(i,0,N) if (comp[2*i] == comp[2*i+1]) return 0;",
			"\t\treturn 1;",
			"\t}",
			"};",
			"",
			"$0",
		],
	},
	"kactl/graph/HLD.h": {
		"scope": "cpp",
		"prefix": "kactl/graph/HLD.h",
		"body": [
			"${1:#include \"../data-structures/LazySegmentTree.h\"}",
			"/**",
			" * Author: Benjamin Qi, Oleksandr Kulkov, chilli",
			" * Date: 2020-01-12",
			" * License: CC0",
			" * Source: https://codeforces.com/blog/entry/53170, https://github.com/bqi343/USACO/blob/master/Implementations/content/graphs%20(12)/Trees%20(10)/HLD%20(10.3).h",
			" * Description: Decomposes a tree into vertex disjoint heavy paths and light",
			" * edges such that the path from any leaf to the root contains at most log(n)",
			" * light edges. Code does additive modifications and max queries, but can",
			" * support commutative segtree modifications/queries on paths and subtrees.",
			" * Takes as input the full adjacency list. VALS\\_EDGES being true means that",
			" * values are stored in the edges, as opposed to the nodes. All values",
			" * initialized to the segtree default. Root must be 0.",
			" * Time: O((\\log N)^2)",
			" * Status: stress-tested against old HLD",
			" */",
			"",
			"template <bool VALS_EDGES> struct HLD {",
			"\tint N, tim = 0;",
			"\tvector<vi> adj;",
			"\tvi par, siz, rt, pos;",
			"\tNode *tree;",
			"\tHLD(vector<vi> adj_)",
			"\t\t: N(sz(adj_)), adj(adj_), par(N, -1), siz(N, 1),",
			"\t\t  rt(N),pos(N),tree(new Node(0, N)){ dfsSz(0); dfsHld(0); }",
			"\tvoid dfsSz(int v) {",
			"\t\tfor (int& u : adj[v]) {",
			"\t\t\tadj[u].erase(find(all(adj[u]), v));",
			"\t\t\tpar[u] = v;",
			"\t\t\tdfsSz(u);",
			"\t\t\tsiz[v] += siz[u];",
			"\t\t\tif (siz[u] > siz[adj[v][0]]) swap(u, adj[v][0]);",
			"\t\t}",
			"\t}",
			"\tvoid dfsHld(int v) {",
			"\t\tpos[v] = tim++;",
			"\t\tfor (int u : adj[v]) {",
			"\t\t\trt[u] = (u == adj[v][0] ? rt[v] : u);",
			"\t\t\tdfsHld(u);",
			"\t\t}",
			"\t}",
			"\ttemplate <class B> void process(int u, int v, B op) {",
			"\t\tfor (;; v = par[rt[v]]) {",
			"\t\t\tif (pos[u] > pos[v]) swap(u, v);",
			"\t\t\tif (rt[u] == rt[v]) break;",
			"\t\t\top(pos[rt[v]], pos[v] + 1);",
			"\t\t}",
			"\t\top(pos[u] + VALS_EDGES, pos[v] + 1);",
			"\t}",
			"\tvoid modifyPath(int u, int v, int val) {",
			"\t\tprocess(u, v, [&](int l, int r) { tree->add(l, r, val); });",
			"\t}",
			"\tint queryPath(int u, int v) { // Modify depending on problem",
			"\t\tint res = -1e9;",
			"\t\tprocess(u, v, [&](int l, int r) {",
			"\t\t\t\tres = max(res, tree->query(l, r));",
			"\t\t});",
			"\t\treturn res;",
			"\t}",
			"\tint querySubtree(int v) { // modifySubtree is similar",
			"\t\treturn tree->query(pos[v] + VALS_EDGES, pos[v] + siz[v]);",
			"\t}",
			"};",
			"",
			"$0",
		],
	},
	"kactl/graph/BinaryLifting.h": {
		"scope": "cpp",
		"prefix": "kactl/graph/BinaryLifting.h",
		"body": [
			"/**",
			" * Author: Johan Sannemo",
			" * Date: 2015-02-06",
			" * License: CC0",
			" * Source: Folklore",
			" * Description: Calculate power of two jumps in a tree,",
			" * to support fast upward jumps and LCAs.",
			" * Assumes the root node points to itself.",
			" * Time: construction \\$O(N \\log N)\\$, queries \\$O(\\log N)\\$",
			" * Status: Tested at Petrozavodsk, also stress-tested via LCA.cpp",
			" */",
			"vector<vi> treeJump(vi& P){",
			"\tint on = 1, d = 1;",
			"\twhile(on < sz(P)) on *= 2, d++;",
			"\tvector<vi> jmp(d, P);",
			"\trep(i,1,d) rep(j,0,sz(P))",
			"\t\tjmp[i][j] = jmp[i-1][jmp[i-1][j]];",
			"\treturn jmp;",
			"}",
			"",
			"int jmp(vector<vi>& tbl, int nod, int steps){",
			"\trep(i,0,sz(tbl))",
			"\t\tif(steps&(1<<i)) nod = tbl[i][nod];",
			"\treturn nod;",
			"}",
			"",
			"int lca(vector<vi>& tbl, vi& depth, int a, int b) {",
			"\tif (depth[a] < depth[b]) swap(a, b);",
			"\ta = jmp(tbl, a, depth[a] - depth[b]);",
			"\tif (a == b) return a;",
			"\tfor (int i = sz(tbl); i--;) {",
			"\t\tint c = tbl[i][a], d = tbl[i][b];",
			"\t\tif (c != d) a = c, b = d;",
			"\t}",
			"\treturn tbl[0][a];",
			"}",
			"",
			"$0",
		],
	},
	"kactl/graph/MaximumClique.h": {
		"scope": "cpp",
		"prefix": "kactl/graph/MaximumClique.h",
		"body": [
			"/**",
			" * Author: chilli, SJTU, Janez Konc",
			" * Date: 2019-05-10",
			" * License: GPL3+",
			" * Source: https://en.wikipedia.org/wiki/MaxCliqueDyn_maximum_clique_algorithm, https://gitlab.com/janezkonc/mcqd/blob/master/mcqd.h",
			" * Description: Quickly finds a maximum clique of a graph (given as symmetric bitset",
			" * matrix; self-edges not allowed). Can be used to find a maximum independent",
			" * set by finding a clique of the complement graph.",
			" * Time: Runs in about 1s for n=155 and worst case random graphs (p=.90). Runs",
			" * faster for sparse graphs.",
			" * Status: stress-tested",
			" */",
			"typedef vector<bitset<200>> vb;",
			"struct Maxclique {",
			"\tdouble limit=0.025, pk=0;",
			"\tstruct Vertex { int i, d=0; };",
			"\ttypedef vector<Vertex> vv;",
			"\tvb e;",
			"\tvv V;",
			"\tvector<vi> C;",
			"\tvi qmax, q, S, old;",
			"\tvoid init(vv& r) {",
			"\t\tfor (auto& v : r) v.d = 0;",
			"\t\tfor (auto& v : r) for (auto j : r) v.d += e[v.i][j.i];",
			"\t\tsort(all(r), [](auto a, auto b) { return a.d > b.d; });",
			"\t\tint mxD = r[0].d;",
			"\t\trep(i,0,sz(r)) r[i].d = min(i, mxD) + 1;",
			"\t}",
			"\tvoid expand(vv& R, int lev = 1) {",
			"\t\tS[lev] += S[lev - 1] - old[lev];",
			"\t\told[lev] = S[lev - 1];",
			"\t\twhile (sz(R)) {",
			"\t\t\tif (sz(q) + R.back().d <= sz(qmax)) return;",
			"\t\t\tq.push_back(R.back().i);",
			"\t\t\tvv T;",
			"\t\t\tfor(auto v:R) if (e[R.back().i][v.i]) T.push_back({v.i});",
			"\t\t\tif (sz(T)) {",
			"\t\t\t\tif (S[lev]++ / ++pk < limit) init(T);",
			"\t\t\t\tint j = 0, mxk = 1, mnk = max(sz(qmax) - sz(q) + 1, 1);",
			"\t\t\t\tC[1].clear(), C[2].clear();",
			"\t\t\t\tfor (auto v : T) {",
			"\t\t\t\t\tint k = 1;",
			"\t\t\t\t\tauto f = [&](int i) { return e[v.i][i]; };",
			"\t\t\t\t\twhile (any_of(all(C[k]), f)) k++;",
			"\t\t\t\t\tif (k > mxk) mxk = k, C[mxk + 1].clear();",
			"\t\t\t\t\tif (k < mnk) T[j++].i = v.i;",
			"\t\t\t\t\tC[k].push_back(v.i);",
			"\t\t\t\t}",
			"\t\t\t\tif (j > 0) T[j - 1].d = 0;",
			"\t\t\t\trep(k,mnk,mxk + 1) for (int i : C[k])",
			"\t\t\t\t\tT[j].i = i, T[j++].d = k;",
			"\t\t\t\texpand(T, lev + 1);",
			"\t\t\t} else if (sz(q) > sz(qmax)) qmax = q;",
			"\t\t\tq.pop_back(), R.pop_back();",
			"\t\t}",
			"\t}",
			"\tvi maxClique() { init(V), expand(V); return qmax; }",
			"\tMaxclique(vb conn) : e(conn), C(sz(e)+1), S(sz(C)), old(S) {",
			"\t\trep(i,0,sz(e)) V.push_back({i});",
			"\t}",
			"};",
			"",
			"$0",
		],
	},
	"kactl/graph/FloydWarshall.h": {
		"scope": "cpp",
		"prefix": "kactl/graph/FloydWarshall.h",
		"body": [
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2016-12-15",
			" * License: CC0",
			" * Source: http://en.wikipedia.org/wiki/Floyd\u2013Warshall_algorithm",
			" * Description: Calculates all-pairs shortest path in a directed graph that might have negative edge weights.",
			" * Input is an distance matrix \\$m\\$, where \\$m[i][j] = \\texttt{inf}\\$ if \\$i\\$ and \\$j\\$ are not adjacent.",
			" * As output, \\$m[i][j]\\$ is set to the shortest distance between \\$i\\$ and \\$j\\$, \\texttt{inf} if no path,",
			" * or \\texttt{-inf} if the path goes through a negative-weight cycle.",
			" * Time: O(N^3)",
			" * Status: slightly tested",
			" */",
			"const ll inf = 1LL << 62;",
			"void floydWarshall(vector<vector<ll>>& m) {",
			"\tint n = sz(m);",
			"\trep(i,0,n) m[i][i] = min(m[i][i], 0LL);",
			"\trep(k,0,n) rep(i,0,n) rep(j,0,n)",
			"\t\tif (m[i][k] != inf && m[k][j] != inf) {",
			"\t\t\tauto newDist = max(m[i][k] + m[k][j], -inf);",
			"\t\t\tm[i][j] = min(m[i][j], newDist);",
			"\t\t}",
			"\trep(k,0,n) if (m[k][k] < 0) rep(i,0,n) rep(j,0,n)",
			"\t\tif (m[i][k] != inf && m[k][j] != inf) m[i][j] = -inf;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/graph/LCA.h": {
		"scope": "cpp",
		"prefix": "kactl/graph/LCA.h",
		"body": [
			"${1:#include \"../data-structures/RMQ.h\"}",
			"/**",
			" * Author: chilli, pajenegod",
			" * Date: 2020-02-20",
			" * License: CC0",
			" * Source: Folklore",
			" * Description: Data structure for computing lowest common ancestors in a tree",
			" * (with 0 as root). C should be an adjacency list of the tree, either directed",
			" * or undirected.",
			" * Time: \\$O(N \\log N + Q)\\$",
			" * Status: stress-tested",
			" */",
			"",
			"struct LCA {",
			"\tint T = 0;",
			"\tvi time, path, ret;",
			"\tRMQ<int> rmq;",
			"",
			"\tLCA(vector<vi>& C) : time(sz(C)), rmq((dfs(C,0,-1), ret)) {}",
			"\tvoid dfs(vector<vi>& C, int v, int par) {",
			"\t\ttime[v] = T++;",
			"\t\tfor (int y : C[v]) if (y != par) {",
			"\t\t\tpath.push_back(v), ret.push_back(time[v]);",
			"\t\t\tdfs(C, y, v);",
			"\t\t}",
			"\t}",
			"",
			"\tint lca(int a, int b) {",
			"\t\tif (a == b) return a;",
			"\t\ttie(a, b) = minmax(time[a], time[b]);",
			"\t\treturn path[rmq.query(a, b)];",
			"\t}",
			"\t//dist(a,b){return depth[a] + depth[b] - 2*depth[lca(a,b)];}",
			"};",
			"",
			"$0",
		],
	},
	"kactl/graph/MaximumIndependentSet.h": {
		"scope": "cpp",
		"prefix": "kactl/graph/MaximumIndependentSet.h",
		"body": [
			"/**",
			" * Author: chilli",
			" * Date: 2019-05-17",
			" * Source: Wikipedia",
			" * Description: To obtain a maximum independent set of a graph, find a max",
			" * clique of the complement. If the graph is bipartite, see MinimumVertexCover.",
			" */",
			"",
			"$0",
		],
	},
	"kactl/graph/BellmanFord.h": {
		"scope": "cpp",
		"prefix": "kactl/graph/BellmanFord.h",
		"body": [
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2015-02-23",
			" * License: CC0",
			" * Source: http://en.wikipedia.org/wiki/Bellman-Ford_algorithm",
			" * Description: Calculates shortest paths from \\$s\\$ in a graph that might have negative edge weights.",
			" * Unreachable nodes get dist = inf; nodes reachable through negative-weight cycles get dist = -inf.",
			" * Assumes \\$V^2 \\max |w_i| < \\tilde{} 2^{63}\\$.",
			" * Time: O(VE)",
			" * Status: Tested on kattis:shortestpath3",
			" */",
			"const ll inf = LLONG_MAX;",
			"struct Ed { int a, b, w, s() { return a < b ? a : -a; }};",
			"struct Node { ll dist = inf; int prev = -1; };",
			"",
			"void bellmanFord(vector<Node>& nodes, vector<Ed>& eds, int s) {",
			"\tnodes[s].dist = 0;",
			"\tsort(all(eds), [](Ed a, Ed b) { return a.s() < b.s(); });",
			"",
			"\tint lim = sz(nodes) / 2 + 2; // /3+100 with shuffled vertices",
			"\trep(i,0,lim) for (Ed ed : eds) {",
			"\t\tNode cur = nodes[ed.a], &dest = nodes[ed.b];",
			"\t\tif (abs(cur.dist) == inf) continue;",
			"\t\tll d = cur.dist + ed.w;",
			"\t\tif (d < dest.dist) {",
			"\t\t\tdest.prev = ed.a;",
			"\t\t\tdest.dist = (i < lim-1 ? d : -inf);",
			"\t\t}",
			"\t}",
			"\trep(i,0,lim) for (Ed e : eds) {",
			"\t\tif (nodes[e.a].dist == -inf)",
			"\t\t\tnodes[e.b].dist = -inf;",
			"\t}",
			"}",
			"",
			"$0",
		],
	},
	"kactl/graph/BiconnectedComponents.h": {
		"scope": "cpp",
		"prefix": "kactl/graph/BiconnectedComponents.h",
		"body": [
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2017-04-17",
			" * License: CC0",
			" * Source: folklore",
			" * Description: Finds all biconnected components in an undirected graph, and",
			" *  runs a callback for the edges in each. In a biconnected component there",
			" *  are at least two distinct paths between any two nodes. Note that a node can",
			" *  be in several components. An edge which is not in a component is a bridge,",
			" *  i.e., not part of any cycle.",
			" * Usage:",
			" *  int eid = 0; ed.resize(N);",
			" *  for each edge (a,b) {",
			" *    ed[a].emplace_back(b, eid);",
			" *    ed[b].emplace_back(a, eid++); }",
			" *  bicomps([\\&](const vi\\& edgelist) {...});",
			" * Time: O(E + V)",
			" * Status: tested during MIPT ICPC Workshop 2017",
			" */",
			"vi num, st;",
			"vector<vector<pii>> ed;",
			"int Time;",
			"template<class F>",
			"int dfs(int at, int par, F& f) {",
			"\tint me = num[at] = ++Time, top = me;",
			"\tfor (auto [y, e] : ed[at]) if (e != par) {",
			"\t\tif (num[y]) {",
			"\t\t\ttop = min(top, num[y]);",
			"\t\t\tif (num[y] < me)",
			"\t\t\t\tst.push_back(e);",
			"\t\t} else {",
			"\t\t\tint si = sz(st);",
			"\t\t\tint up = dfs(y, e, f);",
			"\t\t\ttop = min(top, up);",
			"\t\t\tif (up == me) {",
			"\t\t\t\tst.push_back(e);",
			"\t\t\t\tf(vi(st.begin() + si, st.end()));",
			"\t\t\t\tst.resize(si);",
			"\t\t\t}",
			"\t\t\telse if (up < me) st.push_back(e);",
			"\t\t\telse { /* e is a bridge */ }",
			"\t\t}",
			"\t}",
			"\treturn top;",
			"}",
			"",
			"template<class F>",
			"void bicomps(F f) {",
			"\tnum.assign(sz(ed), 0);",
			"\trep(i,0,sz(ed)) if (!num[i]) dfs(i, -1, f);",
			"}",
			"",
			"$0",
		],
	},
	"kactl/graph/DirectedMST.h": {
		"scope": "cpp",
		"prefix": "kactl/graph/DirectedMST.h",
		"body": [
			"${1:#include \"../data-structures/UnionFindRollback.h\"}",
			"/**",
			" * Author: chilli, Takanori MAEHARA, Benq, Simon Lindholm",
			" * Date: 2019-05-10",
			" * License: CC0",
			" * Source: https://github.com/spaghetti-source/algorithm/blob/master/graph/arborescence.cc",
			" * and https://github.com/bqi343/USACO/blob/42d177dfb9d6ce350389583cfa71484eb8ae614c/Implementations/content/graphs%20(12)/Advanced/DirectedMST.h for the reconstruction",
			" * Description: Finds a minimum spanning",
			" * tree/arborescence of a directed graph, given a root node. If no MST exists, returns -1.",
			" * Time: O(E \\log V)",
			" * Status: Stress-tested, also tested on NWERC 2018 fastestspeedrun",
			" */",
			"",
			"struct Edge { int a, b; ll w; };",
			"struct Node { /// lazy skew heap node",
			"\tEdge key;",
			"\tNode *l, *r;",
			"\tll delta;",
			"\tvoid prop() {",
			"\t\tkey.w += delta;",
			"\t\tif (l) l->delta += delta;",
			"\t\tif (r) r->delta += delta;",
			"\t\tdelta = 0;",
			"\t}",
			"\tEdge top() { prop(); return key; }",
			"};",
			"Node *merge(Node *a, Node *b) {",
			"\tif (!a || !b) return a ?: b;",
			"\ta->prop(), b->prop();",
			"\tif (a->key.w > b->key.w) swap(a, b);",
			"\tswap(a->l, (a->r = merge(b, a->r)));",
			"\treturn a;",
			"}",
			"void pop(Node*& a) { a->prop(); a = merge(a->l, a->r); }",
			"",
			"pair<ll, vi> dmst(int n, int r, vector<Edge>& g) {",
			"\tRollbackUF uf(n);",
			"\tvector<Node*> heap(n);",
			"\tfor (Edge e : g) heap[e.b] = merge(heap[e.b], new Node{e});",
			"\tll res = 0;",
			"\tvi seen(n, -1), path(n), par(n);",
			"\tseen[r] = r;",
			"\tvector<Edge> Q(n), in(n, {-1,-1}), comp;",
			"\tdeque<tuple<int, int, vector<Edge>>> cycs;",
			"\trep(s,0,n) {",
			"\t\tint u = s, qi = 0, w;",
			"\t\twhile (seen[u] < 0) {",
			"\t\t\tif (!heap[u]) return {-1,{}};",
			"\t\t\tEdge e = heap[u]->top();",
			"\t\t\theap[u]->delta -= e.w, pop(heap[u]);",
			"\t\t\tQ[qi] = e, path[qi++] = u, seen[u] = s;",
			"\t\t\tres += e.w, u = uf.find(e.a);",
			"\t\t\tif (seen[u] == s) { /// found cycle, contract",
			"\t\t\t\tNode* cyc = 0;",
			"\t\t\t\tint end = qi, time = uf.time();",
			"\t\t\t\tdo cyc = merge(cyc, heap[w = path[--qi]]);",
			"\t\t\t\twhile (uf.join(u, w));",
			"\t\t\t\tu = uf.find(u), heap[u] = cyc, seen[u] = -1;",
			"\t\t\t\tcycs.push_front({u, time, {&Q[qi], &Q[end]}});",
			"\t\t\t}",
			"\t\t}",
			"\t\trep(i,0,qi) in[uf.find(Q[i].b)] = Q[i];",
			"\t}",
			"",
			"\tfor (auto& [u,t,comp] : cycs) { // restore sol (optional)",
			"\t\tuf.rollback(t);",
			"\t\tEdge inEdge = in[u];",
			"\t\tfor (auto& e : comp) in[uf.find(e.b)] = e;",
			"\t\tin[uf.find(inEdge.b)] = inEdge;",
			"\t}",
			"\trep(i,0,n) par[i] = in[i].a;",
			"\treturn {res, par};",
			"}",
			"",
			"$0",
		],
	},
	"kactl/graph/PushRelabel.h": {
		"scope": "cpp",
		"prefix": "kactl/graph/PushRelabel.h",
		"body": [
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2015-02-24",
			" * License: CC0",
			" * Source: Wikipedia, tinyKACTL",
			" * Description: Push-relabel using the highest label selection rule and the gap heuristic. Quite fast in practice.",
			" *  To obtain the actual flow, look at positive values only.",
			" * Time: \\$O(V^2\\sqrt E)\\$",
			" * Status: Tested on Kattis and SPOJ, and stress-tested",
			" */",
			"struct PushRelabel {",
			"\tstruct Edge {",
			"\t\tint dest, back;",
			"\t\tll f, c;",
			"\t};",
			"\tvector<vector<Edge>> g;",
			"\tvector<ll> ec;",
			"\tvector<Edge*> cur;",
			"\tvector<vi> hs; vi H;",
			"\tPushRelabel(int n) : g(n), ec(n), cur(n), hs(2*n), H(n) {}",
			"",
			"\tvoid addEdge(int s, int t, ll cap, ll rcap=0) {",
			"\t\tif (s == t) return;",
			"\t\tg[s].push_back({t, sz(g[t]), 0, cap});",
			"\t\tg[t].push_back({s, sz(g[s])-1, 0, rcap});",
			"\t}",
			"",
			"\tvoid addFlow(Edge& e, ll f) {",
			"\t\tEdge &back = g[e.dest][e.back];",
			"\t\tif (!ec[e.dest] && f) hs[H[e.dest]].push_back(e.dest);",
			"\t\te.f += f; e.c -= f; ec[e.dest] += f;",
			"\t\tback.f -= f; back.c += f; ec[back.dest] -= f;",
			"\t}",
			"\tll calc(int s, int t) {",
			"\t\tint v = sz(g); H[s] = v; ec[t] = 1;",
			"\t\tvi co(2*v); co[0] = v-1;",
			"\t\trep(i,0,v) cur[i] = g[i].data();",
			"\t\tfor (Edge& e : g[s]) addFlow(e, e.c);",
			"",
			"\t\tfor (int hi = 0;;) {",
			"\t\t\twhile (hs[hi].empty()) if (!hi--) return -ec[s];",
			"\t\t\tint u = hs[hi].back(); hs[hi].pop_back();",
			"\t\t\twhile (ec[u] > 0)  // discharge u",
			"\t\t\t\tif (cur[u] == g[u].data() + sz(g[u])) {",
			"\t\t\t\t\tH[u] = 1e9;",
			"\t\t\t\t\tfor (Edge& e : g[u]) if (e.c && H[u] > H[e.dest]+1)",
			"\t\t\t\t\t\tH[u] = H[e.dest]+1, cur[u] = &e;",
			"\t\t\t\t\tif (++co[H[u]], !--co[hi] && hi < v)",
			"\t\t\t\t\t\trep(i,0,v) if (hi < H[i] && H[i] < v)",
			"\t\t\t\t\t\t\t--co[H[i]], H[i] = v + 1;",
			"\t\t\t\t\thi = H[u];",
			"\t\t\t\t} else if (cur[u]->c && H[u] == H[cur[u]->dest]+1)",
			"\t\t\t\t\taddFlow(*cur[u], min(ec[u], cur[u]->c));",
			"\t\t\t\telse ++cur[u];",
			"\t\t}",
			"\t}",
			"\tbool leftOfMinCut(int a) { return H[a] >= sz(g); }",
			"};",
			"",
			"$0",
		],
	},
	"kactl/graph/EulerWalk.h": {
		"scope": "cpp",
		"prefix": "kactl/graph/EulerWalk.h",
		"body": [
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2019-12-31",
			" * License: CC0",
			" * Source: folklore",
			" * Description: Eulerian undirected/directed path/cycle algorithm.",
			" * Input should be a vector of (dest, global edge index), where",
			" * for undirected graphs, forward/backward edges have the same index.",
			" * Returns a list of nodes in the Eulerian path/cycle with src at both start and end, or",
			" * empty list if no cycle/path exists.",
			" * To get edge indices back, add .second to s and ret.",
			" * Time: O(V + E)",
			" * Status: stress-tested",
			" */",
			"vi eulerWalk(vector<vector<pii>>& gr, int nedges, int src=0) {",
			"\tint n = sz(gr);",
			"\tvi D(n), its(n), eu(nedges), ret, s = {src};",
			"\tD[src]++; // to allow Euler paths, not just cycles",
			"\twhile (!s.empty()) {",
			"\t\tint x = s.back(), y, e, &it = its[x], end = sz(gr[x]);",
			"\t\tif (it == end){ ret.push_back(x); s.pop_back(); continue; }",
			"\t\ttie(y, e) = gr[x][it++];",
			"\t\tif (!eu[e]) {",
			"\t\t\tD[x]--, D[y]++;",
			"\t\t\teu[e] = 1; s.push_back(y);",
			"\t\t}}",
			"\tfor (int x : D) if (x < 0 || sz(ret) != nedges+1) return {};",
			"\treturn {ret.rbegin(), ret.rend()};",
			"}",
			"",
			"$0",
		],
	},
	"kactl/strings/MinRotation.h": {
		"scope": "cpp",
		"prefix": "kactl/strings/MinRotation.h",
		"body": [
			"/**",
			" * Author: Stjepan Glavina",
			" * License: Unlicense",
			" * Source: https://github.com/stjepang/snippets/blob/master/min_rotation.cpp",
			" * Description: Finds the lexicographically smallest rotation of a string.",
			" * Time: O(N)",
			" * Usage:",
			" *  rotate(v.begin(), v.begin()+minRotation(v), v.end());",
			" * Status: Stress-tested",
			" */",
			"int minRotation(string s) {",
			"\tint a=0, N=sz(s); s += s;",
			"\trep(b,0,N) rep(k,0,N) {",
			"\t\tif (a+k == b || s[a+k] < s[b+k]) {b += max(0, k-1); break;}",
			"\t\tif (s[a+k] > s[b+k]) { a = b; break; }",
			"\t}",
			"\treturn a;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/strings/Zfunc.h": {
		"scope": "cpp",
		"prefix": "kactl/strings/Zfunc.h",
		"body": [
			"/**",
			" * Author: chilli",
			" * License: CC0",
			" * Description: z[i] computes the length of the longest common prefix of s[i:] and s,",
			" * except z[0] = 0. (abacaba -> 0010301)",
			" * Time: O(n)",
			" * Status: stress-tested",
			" */",
			"vi Z(const string& S) {",
			"\tvi z(sz(S));",
			"\tint l = -1, r = -1;",
			"\trep(i,1,sz(S)) {",
			"\t\tz[i] = i >= r ? 0 : min(r - i, z[i - l]);",
			"\t\twhile (i + z[i] < sz(S) && S[i + z[i]] == S[z[i]])",
			"\t\t\tz[i]++;",
			"\t\tif (i + z[i] > r)",
			"\t\t\tl = i, r = i + z[i];",
			"\t}",
			"\treturn z;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/strings/SuffixTree.h": {
		"scope": "cpp",
		"prefix": "kactl/strings/SuffixTree.h",
		"body": [
			"/**",
			" * Author: Unknown",
			" * Date: 2017-05-15",
			" * Source: https://e-maxx.ru/algo/ukkonen",
			" * Description: Ukkonen's algorithm for online suffix tree construction.",
			" *  Each node contains indices [l, r) into the string, and a list of child nodes.",
			" *  Suffixes are given by traversals of this tree, joining [l, r) substrings.",
			" *  The root is 0 (has l = -1, r = 0), non-existent children are -1.",
			" *  To get a complete tree, append a dummy symbol -- otherwise it may contain",
			" *  an incomplete path (still useful for substring matching, though).",
			" * Time: \\$O(26N)\\$",
			" * Status: stress-tested a bit",
			" */",
			"struct SuffixTree {",
			"\tenum { N = 200010, ALPHA = 26 }; // N ~ 2*maxlen+10",
			"\tint toi(char c) { return c - 'a'; }",
			"\tstring a; // v = cur node, q = cur position",
			"\tint t[N][ALPHA],l[N],r[N],p[N],s[N],v=0,q=0,m=2;",
			"",
			"\tvoid ukkadd(int i, int c) { suff:",
			"\t\tif (r[v]<=q) {",
			"\t\t\tif (t[v][c]==-1) { t[v][c]=m;  l[m]=i;",
			"\t\t\t\tp[m++]=v; v=s[v]; q=r[v];  goto suff; }",
			"\t\t\tv=t[v][c]; q=l[v];",
			"\t\t}",
			"\t\tif (q==-1 || c==toi(a[q])) q++; else {",
			"\t\t\tl[m+1]=i;  p[m+1]=m;  l[m]=l[v];  r[m]=q;",
			"\t\t\tp[m]=p[v];  t[m][c]=m+1;  t[m][toi(a[q])]=v;",
			"\t\t\tl[v]=q;  p[v]=m;  t[p[m]][toi(a[l[m]])]=m;",
			"\t\t\tv=s[p[m]];  q=l[m];",
			"\t\t\twhile (q<r[m]) { v=t[v][toi(a[q])];  q+=r[v]-l[v]; }",
			"\t\t\tif (q==r[m])  s[m]=v;  else s[m]=m+2;",
			"\t\t\tq=r[v]-(q-r[m]);  m+=2;  goto suff;",
			"\t\t}",
			"\t}",
			"",
			"\tSuffixTree(string a) : a(a) {",
			"\t\tfill(r,r+N,sz(a));",
			"\t\tmemset(s, 0, sizeof s);",
			"\t\tmemset(t, -1, sizeof t);",
			"\t\tfill(t[1],t[1]+ALPHA,0);",
			"\t\ts[0] = 1; l[0] = l[1] = -1; r[0] = r[1] = p[0] = p[1] = 0;",
			"\t\trep(i,0,sz(a)) ukkadd(i, toi(a[i]));",
			"\t}",
			"",
			"\t// example: find longest common substring (uses ALPHA = 28)",
			"\tpii best;",
			"\tint lcs(int node, int i1, int i2, int olen) {",
			"\t\tif (l[node] <= i1 && i1 < r[node]) return 1;",
			"\t\tif (l[node] <= i2 && i2 < r[node]) return 2;",
			"\t\tint mask = 0, len = node ? olen + (r[node] - l[node]) : 0;",
			"\t\trep(c,0,ALPHA) if (t[node][c] != -1)",
			"\t\t\tmask |= lcs(t[node][c], i1, i2, len);",
			"\t\tif (mask == 3)",
			"\t\t\tbest = max(best, {len, r[node] - len});",
			"\t\treturn mask;",
			"\t}",
			"\tstatic pii LCS(string s, string t) {",
			"\t\tSuffixTree st(s + (char)('z' + 1) + t + (char)('z' + 2));",
			"\t\tst.lcs(0, sz(s), sz(s) + 1 + sz(t), 0);",
			"\t\treturn st.best;",
			"\t}",
			"};",
			"",
			"$0",
		],
	},
	"kactl/strings/Hashing-codeforces.h": {
		"scope": "cpp",
		"prefix": "kactl/strings/Hashing-codeforces.h",
		"body": [
			"${1:#include <sys/time.h>}",
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2015-03-15",
			" * License: CC0",
			" * Source: own work",
			" * Description: Various self-explanatory methods for string hashing.",
			" * Use on Codeforces, which lacks 64-bit support and where solutions can be hacked.",
			" * Status: stress-tested",
			" */",
			"typedef uint64_t ull;",
			"static int C; // initialized below",
			"",
			"// Arithmetic mod two primes and 2^32 simultaneously.",
			"// \"typedef uint64_t H;\" instead if Thue-Morse does not apply.",
			"template<int M, class B>",
			"struct A {",
			"\tint x; B b; A(int x=0) : x(x), b(x) {}",
			"\tA(int x, B b) : x(x), b(b) {}",
			"\tA operator+(A o){int y = x+o.x; return{y - (y>=M)*M, b+o.b};}",
			"\tA operator-(A o){int y = x-o.x; return{y + (y< 0)*M, b-o.b};}",
			"\tA operator*(A o) { return {(int)(1LL*x*o.x % M), b*o.b}; }",
			"\texplicit operator ull() { return x ^ (ull) b << 21; }",
			"\tbool operator==(A o) const { return (ull)*this == (ull)o; }",
			"\tbool operator<(A o) const { return (ull)*this < (ull)o; }",
			"};",
			"typedef A<1000000007, A<1000000009, unsigned>> H;",
			"",
			"struct HashInterval {",
			"\tvector<H> ha, pw;",
			"\tHashInterval(string& str) : ha(sz(str)+1), pw(ha) {",
			"\t\tpw[0] = 1;",
			"\t\trep(i,0,sz(str))",
			"\t\t\tha[i+1] = ha[i] * C + str[i],",
			"\t\t\tpw[i+1] = pw[i] * C;",
			"\t}",
			"\tH hashInterval(int a, int b) { // hash [a, b)",
			"\t\treturn ha[b] - ha[a] * pw[b - a];",
			"\t}",
			"};",
			"",
			"vector<H> getHashes(string& str, int length) {",
			"\tif (sz(str) < length) return {};",
			"\tH h = 0, pw = 1;",
			"\trep(i,0,length)",
			"\t\th = h * C + str[i], pw = pw * C;",
			"\tvector<H> ret = {h};",
			"\trep(i,length,sz(str)) {",
			"\t\tret.push_back(h = h * C + str[i] - pw * str[i-length]);",
			"\t}",
			"\treturn ret;",
			"}",
			"",
			"H hashString(string& s){H h{}; for(char c:s) h=h*C+c;return h;}",
			"",
			"int main() {",
			"\ttimeval tp;",
			"\tgettimeofday(&tp, 0);",
			"\tC = (int)tp.tv_usec; // (less than modulo)",
			"\tassert((ull)(H(1)*2+1-3) == 0);",
			"\t// ...",
			"}",
			"",
			"$0",
		],
	},
	"kactl/strings/Hashing.h": {
		"scope": "cpp",
		"prefix": "kactl/strings/Hashing.h",
		"body": [
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2015-03-15",
			" * License: CC0",
			" * Source: own work",
			" * Description: Self-explanatory methods for string hashing.",
			" * Status: stress-tested",
			" */",
			"// Arithmetic mod 2^64-1. 2x slower than mod 2^64 and more",
			"// code, but works on evil test data (e.g. Thue-Morse, where",
			"// ABBA... and BAAB... of length 2^10 hash the same mod 2^64).",
			"// \"typedef ull H;\" instead if you think test data is random,",
			"// or work mod 10^9+7 if the Birthday paradox is not a problem.",
			"typedef uint64_t ull;",
			"struct H {",
			"\tull x; H(ull x=0) : x(x) {}",
			"\tH operator+(H o) { return x + o.x + (x + o.x < x); }",
			"\tH operator-(H o) { return *this + ~o.x; }",
			"\tH operator*(H o) { auto m = (__uint128_t)x * o.x;",
			"\t\treturn H((ull)m) + (ull)(m >> 64); }",
			"\tull get() const { return x + !~x; }",
			"\tbool operator==(H o) const { return get() == o.get(); }",
			"\tbool operator<(H o) const { return get() < o.get(); }",
			"};",
			"static const H C = (ll)1e11+3; // (order ~ 3e9; random also ok)",
			"",
			"struct HashInterval {",
			"\tvector<H> ha, pw;",
			"\tHashInterval(string& str) : ha(sz(str)+1), pw(ha) {",
			"\t\tpw[0] = 1;",
			"\t\trep(i,0,sz(str))",
			"\t\t\tha[i+1] = ha[i] * C + str[i],",
			"\t\t\tpw[i+1] = pw[i] * C;",
			"\t}",
			"\tH hashInterval(int a, int b) { // hash [a, b)",
			"\t\treturn ha[b] - ha[a] * pw[b - a];",
			"\t}",
			"};",
			"",
			"vector<H> getHashes(string& str, int length) {",
			"\tif (sz(str) < length) return {};",
			"\tH h = 0, pw = 1;",
			"\trep(i,0,length)",
			"\t\th = h * C + str[i], pw = pw * C;",
			"\tvector<H> ret = {h};",
			"\trep(i,length,sz(str)) {",
			"\t\tret.push_back(h = h * C + str[i] - pw * str[i-length]);",
			"\t}",
			"\treturn ret;",
			"}",
			"",
			"H hashString(string& s){H h{}; for(char c:s) h=h*C+c;return h;}",
			"",
			"$0",
		],
	},
	"kactl/strings/Manacher.h": {
		"scope": "cpp",
		"prefix": "kactl/strings/Manacher.h",
		"body": [
			"/**",
			" * Author: User adamant on CodeForces",
			" * Source: http://codeforces.com/blog/entry/12143",
			" * Description: For each position in a string, computes p[0][i] = half length of",
			" *  longest even palindrome around pos i, p[1][i] = longest odd (half rounded down).",
			" * Time: O(N)",
			" * Status: Stress-tested",
			" */",
			"array<vi, 2> manacher(const string& s) {",
			"\tint n = sz(s);",
			"\tarray<vi,2> p = {vi(n+1), vi(n)};",
			"\trep(z,0,2) for (int i=0,l=0,r=0; i < n; i++) {",
			"\t\tint t = r-i+!z;",
			"\t\tif (i<r) p[z][i] = min(t, p[z][l+t]);",
			"\t\tint L = i-p[z][i], R = i+p[z][i]-!z;",
			"\t\twhile (L>=1 && R+1<n && s[L-1] == s[R+1])",
			"\t\t\tp[z][i]++, L--, R++;",
			"\t\tif (R>r) l=L, r=R;",
			"\t}",
			"\treturn p;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/strings/SuffixArray.h": {
		"scope": "cpp",
		"prefix": "kactl/strings/SuffixArray.h",
		"body": [
			"/**",
			" * Author: \u7f57\u7a57\u9a9e, chilli",
			" * Date: 2019-04-11",
			" * License: Unknown",
			" * Source: Suffix array - a powerful tool for dealing with strings",
			" * (Chinese IOI National team training paper, 2009)",
			" * Description: Builds suffix array for a string.",
			" * \\texttt{sa[i]} is the starting index of the suffix which",
			" * is \\$i\\$'th in the sorted suffix array.",
			" * The returned vector is of size \\$n+1\\$, and \\texttt{sa[0] = n}.",
			" * The \\texttt{lcp} array contains longest common prefixes for",
			" * neighbouring strings in the suffix array:",
			" * \\texttt{lcp[i] = lcp(sa[i], sa[i-1])}, \\texttt{lcp[0] = 0}.",
			" * The input string must not contain any nul chars.",
			" * Time: O(n \\log n)",
			" * Status: stress-tested",
			" */",
			"struct SuffixArray {",
			"\tvi sa, lcp;",
			"\tSuffixArray(string s, int lim=256) { // or vector<int>",
			"\t\ts.push_back(0); int n = sz(s), k = 0, a, b;",
			"\t\tvi x(all(s)), y(n), ws(max(n, lim));",
			"\t\tsa = lcp = y, iota(all(sa), 0);",
			"\t\tfor (int j = 0, p = 0; p < n; j = max(1, j * 2), lim = p) {",
			"\t\t\tp = j, iota(all(y), n - j);",
			"\t\t\trep(i,0,n) if (sa[i] >= j) y[p++] = sa[i] - j;",
			"\t\t\tfill(all(ws), 0);",
			"\t\t\trep(i,0,n) ws[x[i]]++;",
			"\t\t\trep(i,1,lim) ws[i] += ws[i - 1];",
			"\t\t\tfor (int i = n; i--;) sa[--ws[x[y[i]]]] = y[i];",
			"\t\t\tswap(x, y), p = 1, x[sa[0]] = 0;",
			"\t\t\trep(i,1,n) a = sa[i - 1], b = sa[i], x[b] =",
			"\t\t\t\t(y[a] == y[b] && y[a + j] == y[b + j]) ? p - 1 : p++;",
			"\t\t}",
			"\t\tfor (int i = 0, j; i < n - 1; lcp[x[i++]] = k)",
			"\t\t\tfor (k && k--, j = sa[x[i] - 1];",
			"\t\t\t\t\ts[i + k] == s[j + k]; k++);",
			"\t}",
			"};",
			"",
			"$0",
		],
	},
	"kactl/strings/AhoCorasick.h": {
		"scope": "cpp",
		"prefix": "kactl/strings/AhoCorasick.h",
		"body": [
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2015-02-18",
			" * License: CC0",
			" * Source: marian's (TC) code",
			" * Description: Aho-Corasick automaton, used for multiple pattern matching.",
			" * Initialize with AhoCorasick ac(patterns); the automaton start node will be at index 0.",
			" * find(word) returns for each position the index of the longest word that ends there, or -1 if none.",
			" * findAll(\\$-\\$, word) finds all words (up to \\$N \\sqrt N\\$ many if no duplicate patterns)",
			" * that start at each position (shortest first).",
			" * Duplicate patterns are allowed; empty patterns are not.",
			" * To find the longest words that start at each position, reverse all input.",
			" * For large alphabets, split each symbol into chunks, with sentinel bits for symbol boundaries.",
			" * Time: construction takes \\$O(26N)\\$, where \\$N =\\$ sum of length of patterns.",
			" * find(x) is \\$O(N)\\$, where N = length of x. findAll is \\$O(NM)\\$.",
			" * Status: stress-tested",
			" */",
			"struct AhoCorasick {",
			"\tenum {alpha = 26, first = 'A'}; // change this!",
			"\tstruct Node {",
			"\t\t// (nmatches is optional)",
			"\t\tint back, next[alpha], start = -1, end = -1, nmatches = 0;",
			"\t\tNode(int v) { memset(next, v, sizeof(next)); }",
			"\t};",
			"\tvector<Node> N;",
			"\tvi backp;",
			"\tvoid insert(string& s, int j) {",
			"\t\tassert(!s.empty());",
			"\t\tint n = 0;",
			"\t\tfor (char c : s) {",
			"\t\t\tint& m = N[n].next[c - first];",
			"\t\t\tif (m == -1) { n = m = sz(N); N.emplace_back(-1); }",
			"\t\t\telse n = m;",
			"\t\t}",
			"\t\tif (N[n].end == -1) N[n].start = j;",
			"\t\tbackp.push_back(N[n].end);",
			"\t\tN[n].end = j;",
			"\t\tN[n].nmatches++;",
			"\t}",
			"\tAhoCorasick(vector<string>& pat) : N(1, -1) {",
			"\t\trep(i,0,sz(pat)) insert(pat[i], i);",
			"\t\tN[0].back = sz(N);",
			"\t\tN.emplace_back(0);",
			"",
			"\t\tqueue<int> q;",
			"\t\tfor (q.push(0); !q.empty(); q.pop()) {",
			"\t\t\tint n = q.front(), prev = N[n].back;",
			"\t\t\trep(i,0,alpha) {",
			"\t\t\t\tint &ed = N[n].next[i], y = N[prev].next[i];",
			"\t\t\t\tif (ed == -1) ed = y;",
			"\t\t\t\telse {",
			"\t\t\t\t\tN[ed].back = y;",
			"\t\t\t\t\t(N[ed].end == -1 ? N[ed].end : backp[N[ed].start])",
			"\t\t\t\t\t\t= N[y].end;",
			"\t\t\t\t\tN[ed].nmatches += N[y].nmatches;",
			"\t\t\t\t\tq.push(ed);",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\tvi find(string word) {",
			"\t\tint n = 0;",
			"\t\tvi res; // ll count = 0;",
			"\t\tfor (char c : word) {",
			"\t\t\tn = N[n].next[c - first];",
			"\t\t\tres.push_back(N[n].end);",
			"\t\t\t// count += N[n].nmatches;",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"\tvector<vi> findAll(vector<string>& pat, string word) {",
			"\t\tvi r = find(word);",
			"\t\tvector<vi> res(sz(word));",
			"\t\trep(i,0,sz(word)) {",
			"\t\t\tint ind = r[i];",
			"\t\t\twhile (ind != -1) {",
			"\t\t\t\tres[i - sz(pat[ind]) + 1].push_back(ind);",
			"\t\t\t\tind = backp[ind];",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"};",
			"",
			"$0",
		],
	},
	"kactl/strings/KMP.h": {
		"scope": "cpp",
		"prefix": "kactl/strings/KMP.h",
		"body": [
			"/**",
			" * Author: Johan Sannemo",
			" * Date: 2016-12-15",
			" * License: CC0",
			" * Description: pi[x] computes the length of the longest prefix of s that ends at x,",
			" * other than s[0...x] itself (abacaba -> 0010123).",
			" * Can be used to find all occurrences of a string.",
			" * Time: O(n)",
			" * Status: Tested on kattis:stringmatching",
			" */",
			"vi pi(const string& s) {",
			"\tvi p(sz(s));",
			"\trep(i,1,sz(s)) {",
			"\t\tint g = p[i-1];",
			"\t\twhile (g && s[i] != s[g]) g = p[g-1];",
			"\t\tp[i] = g + (s[i] == s[g]);",
			"\t}",
			"\treturn p;",
			"}",
			"",
			"vi match(const string& s, const string& pat) {",
			"\tvi p = pi(pat + '\\0' + s), res;",
			"\trep(i,sz(p)-sz(s),sz(p))",
			"\t\tif (p[i] == sz(pat)) res.push_back(i - 2 * sz(pat));",
			"\treturn res;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/number-theory/ModInverse.h": {
		"scope": "cpp",
		"prefix": "kactl/number-theory/ModInverse.h",
		"body": [
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2016-07-24",
			" * License: CC0",
			" * Source: Russian page",
			" * Description: Pre-computation of modular inverses. Assumes LIM \\$\\le\\$ mod and that mod is a prime.",
			" * Status: Works",
			" */",
			"// const ll mod = 1000000007, LIM = 200000; ///include-line",
			"ll* inv = new ll[LIM] - 1; inv[1] = 1;",
			"rep(i,2,LIM) inv[i] = mod - (mod / i) * inv[mod % i] % mod;",
			"",
			"$0",
		],
	},
	"kactl/number-theory/FastEratosthenes.h": {
		"scope": "cpp",
		"prefix": "kactl/number-theory/FastEratosthenes.h",
		"body": [
			"/**",
			" * Author: Jakob Kogler, chilli, pajenegod",
			" * Date: 2020-04-12",
			" * License: CC0",
			" * Description: Prime sieve for generating all primes smaller than LIM.",
			" * Time: LIM=1e9 \\$\\approx\\$ 1.5s",
			" * Status: Stress-tested",
			" * Details: Despite its n log log n complexity, segmented sieve is still faster",
			" * than other options, including bitset sieves and linear sieves. This is",
			" * primarily due to its low memory usage, which reduces cache misses. This",
			" * implementation skips even numbers.",
			" *",
			" * Benchmark can be found here: https://ideone.com/e7TbX4",
			" *",
			" * The line `for (int i=idx; i<S+L; idx = (i += p))` is done on purpose for performance reasons.",
			" * Se https://github.com/kth-competitive-programming/kactl/pull/166#discussion_r408354338",
			" */",
			"const int LIM = 1e6;",
			"bitset<LIM> isPrime;",
			"vi eratosthenes() {",
			"\tconst int S = (int)round(sqrt(LIM)), R = LIM / 2;",
			"\tvi pr = {2}, sieve(S+1); pr.reserve(int(LIM/log(LIM)*1.1));",
			"\tvector<pii> cp;",
			"\tfor (int i = 3; i <= S; i += 2) if (!sieve[i]) {",
			"\t\tcp.push_back({i, i * i / 2});",
			"\t\tfor (int j = i * i; j <= S; j += 2 * i) sieve[j] = 1;",
			"\t}",
			"\tfor (int L = 1; L <= R; L += S) {",
			"\t\tarray<bool, S> block{};",
			"\t\tfor (auto &[p, idx] : cp)",
			"\t\t\tfor (int i=idx; i < S+L; idx = (i+=p)) block[i-L] = 1;",
			"\t\trep(i,0,min(S, R - L))",
			"\t\t\tif (!block[i]) pr.push_back((L + i) * 2 + 1);",
			"\t}",
			"\tfor (int i : pr) isPrime[i] = 1;",
			"\treturn pr;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/number-theory/MillerRabin.h": {
		"scope": "cpp",
		"prefix": "kactl/number-theory/MillerRabin.h",
		"body": [
			"${1:#include \"ModMulLL.h\"}",
			"/**",
			" * Author: chilli, c1729, Simon Lindholm",
			" * Date: 2019-03-28",
			" * License: CC0",
			" * Source: Wikipedia, https://miller-rabin.appspot.com/",
			" * Description: Deterministic Miller-Rabin primality test.",
			" * Guaranteed to work for numbers up to \\$7 \\cdot 10^{18}\\$; for larger numbers, use Python and extend A randomly.",
			" * Time: 7 times the complexity of \\$a^b \\mod c\\$.",
			" * Status: Stress-tested",
			" */",
			"",
			"bool isPrime(ull n) {",
			"\tif (n < 2 || n % 6 % 4 != 1) return (n | 1) == 3;",
			"\tull A[] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022},",
			"\t    s = __builtin_ctzll(n-1), d = n >> s;",
			"\tfor (ull a : A) {   // ^ count trailing zeroes",
			"\t\tull p = modpow(a%n, d, n), i = s;",
			"\t\twhile (p != 1 && p != n - 1 && a % n && i--)",
			"\t\t\tp = modmul(p, p, n);",
			"\t\tif (p != n-1 && i != s) return 0;",
			"\t}",
			"\treturn 1;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/number-theory/ModLog.h": {
		"scope": "cpp",
		"prefix": "kactl/number-theory/ModLog.h",
		"body": [
			"/**",
			" * Author: Bjorn Martinsson",
			" * Date: 2020-06-03",
			" * License: CC0",
			" * Source: own work",
			" * Description: Returns the smallest \\$x > 0\\$ s.t. \\$a^x = b \\pmod m\\$, or",
			" * \\$-1\\$ if no such \\$x\\$ exists. modLog(a,1,m) can be used to",
			" * calculate the order of \\$a\\$.",
			" * Time: \\$O(\\sqrt m)\\$",
			" * Status: tested for all 0 <= a,x < 500 and 0 < m < 500.",
			" *",
			" * Details: This algorithm uses the baby-step giant-step method to",
			" * find (i,j) such that a^(n * i) = b * a^j (mod m), where n > sqrt(m)",
			" * and 0 < i, j <= n. If a and m are coprime then a^j has a modular",
			" * inverse, which means that a^(i * n - j) = b (mod m\\$).",
			" *",
			" * However this particular implementation of baby-step giant-step works even",
			" * without assuming a and m are coprime, using the following idea:",
			" *",
			" * Assume p^x is a prime divisor of m. Then we have 3 cases",
			" *\t 1. b is divisible by p^x",
			" *\t 2. b is divisible only by some p^y, 0<y<x",
			" *\t 3. b is not divisible by p",
			" * The important thing to note is that in case 2, modLog(a,b,m) (if",
			" * it exists) cannot be > sqrt(m), (technically it cannot be >= log2(m)).",
			" * So once all exponenents of a that are <= sqrt(m) has been checked, you",
			" * cannot have case 2. Case 2 is the only tricky case.",
			" *",
			" * So the modification allowing for non-coprime input involves checking all",
			" * exponents of a that are <= n, and then handling the non-tricky cases by",
			" * a simple gcd(a^n,m) == gcd(b,m) check.",
			" */",
			"ll modLog(ll a, ll b, ll m) {",
			"\tll n = (ll) sqrt(m) + 1, e = 1, f = 1, j = 1;",
			"\tunordered_map<ll, ll> A;",
			"\twhile (j <= n && (e = f = e * a % m) != b % m)",
			"\t\tA[e * b % m] = j++;",
			"\tif (e == b % m) return j;",
			"\tif (__gcd(m, e) == __gcd(m, b)) ",
			"\t\trep(i,2,n+2) if (A.count(e = e * f % m))",
			"\t\t\treturn n * i - A[e];",
			"\treturn -1;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/number-theory/ModularArithmetic.h": {
		"scope": "cpp",
		"prefix": "kactl/number-theory/ModularArithmetic.h",
		"body": [
			"${1:#include \"euclid.h\"}",
			"/**",
			" * Author: Lukas Polacek",
			" * Date: 2009-09-28",
			" * License: CC0",
			" * Source: folklore",
			" * Description: Operators for modular arithmetic. You need to set {\\tt mod} to",
			" * some number first and then you can use the structure.",
			" */",
			"",
			"const ll mod = 17; // change to something else",
			"struct Mod {",
			"\tll x;",
			"\tMod(ll xx) : x(xx) {}",
			"\tMod operator+(Mod b) { return Mod((x + b.x) % mod); }",
			"\tMod operator-(Mod b) { return Mod((x - b.x + mod) % mod); }",
			"\tMod operator*(Mod b) { return Mod((x * b.x) % mod); }",
			"\tMod operator/(Mod b) { return *this * invert(b); }",
			"\tMod invert(Mod a) {",
			"\t\tll x, y, g = euclid(a.x, mod, x, y);",
			"\t\tassert(g == 1); return Mod((x + mod) % mod);",
			"\t}",
			"\tMod operator^(ll e) {",
			"\t\tif (!e) return Mod(1);",
			"\t\tMod r = *this ^ (e / 2); r = r * r;",
			"\t\treturn e&1 ? *this * r : r;",
			"\t}",
			"};",
			"",
			"$0",
		],
	},
	"kactl/number-theory/ModSqrt.h": {
		"scope": "cpp",
		"prefix": "kactl/number-theory/ModSqrt.h",
		"body": [
			"${1:#include \"ModPow.h\"}",
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2016-08-31",
			" * License: CC0",
			" * Source: http://eli.thegreenplace.net/2009/03/07/computing-modular-square-roots-in-python/",
			" * Description: Tonelli-Shanks algorithm for modular square roots. Finds \\$x\\$ s.t. \\$x^2 = a \\pmod p\\$ (\\$-x\\$ gives the other solution).",
			" * Time: O(\\log^2 p) worst case, O(\\log p) for most \\$p\\$",
			" * Status: Tested for all a,p <= 10000",
			" */",
			"",
			"ll sqrt(ll a, ll p) {",
			"\ta %= p; if (a < 0) a += p;",
			"\tif (a == 0) return 0;",
			"\tassert(modpow(a, (p-1)/2, p) == 1); // else no solution",
			"\tif (p % 4 == 3) return modpow(a, (p+1)/4, p);",
			"\t// a^(n+3)/8 or 2^(n+3)/8 * 2^(n-1)/4 works if p % 8 == 5",
			"\tll s = p - 1, n = 2;",
			"\tint r = 0, m;",
			"\twhile (s % 2 == 0)",
			"\t\t++r, s /= 2;",
			"\t/// find a non-square mod p",
			"\twhile (modpow(n, (p - 1) / 2, p) != p - 1) ++n;",
			"\tll x = modpow(a, (s + 1) / 2, p);",
			"\tll b = modpow(a, s, p), g = modpow(n, s, p);",
			"\tfor (;; r = m) {",
			"\t\tll t = b;",
			"\t\tfor (m = 0; m < r && t != 1; ++m)",
			"\t\t\tt = t * t % p;",
			"\t\tif (m == 0) return x;",
			"\t\tll gs = modpow(g, 1LL << (r - m - 1), p);",
			"\t\tg = gs * gs % p;",
			"\t\tx = x * gs % p;",
			"\t\tb = b * g % p;",
			"\t}",
			"}",
			"",
			"$0",
		],
	},
	"kactl/number-theory/ModMulLL.h": {
		"scope": "cpp",
		"prefix": "kactl/number-theory/ModMulLL.h",
		"body": [
			"/**",
			" * Author: chilli, Ramchandra Apte, Noam527, Simon Lindholm",
			" * Date: 2019-04-24",
			" * License: CC0",
			" * Source: https://github.com/RamchandraApte/OmniTemplate/blob/master/src/number_theory/modulo.hpp",
			" * Description: Calculate \\$a\\cdot b\\bmod c\\$ (or \\$a^b \\bmod c\\$) for \\$0 \\le a, b \\le c \\le 7.2\\cdot 10^{18}\\$.",
			" * Time: O(1) for \\texttt{modmul}, O(\\log b) for \\texttt{modpow}",
			" * Status: stress-tested, proven correct",
			" * Details:",
			" * This runs ~2x faster than the naive (__int128_t)a * b % M.",
			" * A proof of correctness is in doc/modmul-proof.tex. An earlier version of the proof,",
			" * from when the code used a * b / (long double)M, is in doc/modmul-proof.md.",
			" * The proof assumes that long doubles are implemented as x87 80-bit floats; if they",
			" * are 64-bit, as on e.g. MSVC, the implementation is only valid for",
			" * \\$0 \\le a, b \\le c < 2^{52} \\approx 4.5 \\cdot 10^{15}\\$.",
			" */",
			"typedef unsigned long long ull;",
			"ull modmul(ull a, ull b, ull M) {",
			"\tll ret = a * b - M * ull(1.L / M * a * b);",
			"\treturn ret + M * (ret < 0) - M * (ret >= (ll)M);",
			"}",
			"ull modpow(ull b, ull e, ull mod) {",
			"\tull ans = 1;",
			"\tfor (; e; b = modmul(b, b, mod), e /= 2)",
			"\t\tif (e & 1) ans = modmul(ans, b, mod);",
			"\treturn ans;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/number-theory/FracBinarySearch.h": {
		"scope": "cpp",
		"prefix": "kactl/number-theory/FracBinarySearch.h",
		"body": [
			"/**",
			" * Author: Lucian Bicsi, Simon Lindholm",
			" * Date: 2017-10-31",
			" * License: CC0",
			" * Description: Given \\$f\\$ and \\$N\\$, finds the smallest fraction \\$p/q \\in [0, 1]\\$",
			" * such that \\$f(p/q)\\$ is true, and \\$p, q \\le N\\$.",
			" * You may want to throw an exception from \\$f\\$ if it finds an exact solution,",
			" * in which case \\$N\\$ can be removed.",
			" * Usage: fracBS([](Frac f) { return f.p>=3*f.q; }, 10); // {1,3}",
			" * Time: O(\\log(N))",
			" * Status: stress-tested for n <= 300",
			" */",
			"",
			"struct Frac { ll p, q; };",
			"",
			"template<class F>",
			"Frac fracBS(F f, ll N) {",
			"\tbool dir = 1, A = 1, B = 1;",
			"\tFrac lo{0, 1}, hi{1, 1}; // Set hi to 1/0 to search (0, N]",
			"\tif (f(lo)) return lo;",
			"\tassert(f(hi));",
			"\twhile (A || B) {",
			"\t\tll adv = 0, step = 1; // move hi if dir, else lo",
			"\t\tfor (int si = 0; step; (step *= 2) >>= si) {",
			"\t\t\tadv += step;",
			"\t\t\tFrac mid{lo.p * adv + hi.p, lo.q * adv + hi.q};",
			"\t\t\tif (abs(mid.p) > N || mid.q > N || dir == !f(mid)) {",
			"\t\t\t\tadv -= step; si = 2;",
			"\t\t\t}",
			"\t\t}",
			"\t\thi.p += lo.p * adv;",
			"\t\thi.q += lo.q * adv;",
			"\t\tdir = !dir;",
			"\t\tswap(lo, hi);",
			"\t\tA = B; B = !!adv;",
			"\t}",
			"\treturn dir ? hi : lo;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/number-theory/CRT.h": {
		"scope": "cpp",
		"prefix": "kactl/number-theory/CRT.h",
		"body": [
			"${1:#include \"euclid.h\"}",
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2019-05-22",
			" * License: CC0",
			" * Description: Chinese Remainder Theorem.",
			" *",
			" * \\texttt{crt(a, m, b, n)} computes \\$x\\$ such that \\$x\\equiv a \\pmod m\\$, \\$x\\equiv b \\pmod n\\$.",
			" * If \\$|a| < m\\$ and \\$|b| < n\\$, \\$x\\$ will obey \\$0 \\le x < \\text{lcm}(m, n)\\$.",
			" * Assumes \\$mn < 2^{62}\\$.",
			" * Time: \\$\\log(n)\\$",
			" * Status: Works",
			" */",
			"",
			"ll crt(ll a, ll m, ll b, ll n) {",
			"\tif (n > m) swap(a, b), swap(m, n);",
			"\tll x, y, g = euclid(m, n, x, y);",
			"\tassert((a - b) % g == 0); // else no solution",
			"\tx = (b - a) % n * x % n / g * m + a;",
			"\treturn x < 0 ? x + m*n/g : x;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/number-theory/ContinuedFractions.h": {
		"scope": "cpp",
		"prefix": "kactl/number-theory/ContinuedFractions.h",
		"body": [
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2018-07-15",
			" * License: CC0",
			" * Source: Wikipedia",
			" * Description: Given \\$N\\$ and a real number \\$x \\ge 0\\$, finds the closest rational approximation \\$p/q\\$ with \\$p, q \\le N\\$.",
			" * It will obey \\$|p/q - x| \\le 1/qN\\$.",
			" *",
			" * For consecutive convergents, \\$p_{k+1}q_k - q_{k+1}p_k = (-1)^k\\$.",
			" * (\\$p_k/q_k\\$ alternates between \\$>x\\$ and \\$<x\\$.)",
			" * If \\$x\\$ is rational, \\$y\\$ eventually becomes \\$\\infty\\$;",
			" * if \\$x\\$ is the root of a degree \\$2\\$ polynomial the \\$a\\$'s eventually become cyclic.",
			" * Time: O(\\log N)",
			" * Status: stress-tested for n <= 300",
			" */",
			"",
			"typedef double d; // for N ~ 1e7; long double for N ~ 1e9",
			"pair<ll, ll> approximate(d x, ll N) {",
			"\tll LP = 0, LQ = 1, P = 1, Q = 0, inf = LLONG_MAX; d y = x;",
			"\tfor (;;) {",
			"\t\tll lim = min(P ? (N-LP) / P : inf, Q ? (N-LQ) / Q : inf),",
			"\t\t   a = (ll)floor(y), b = min(a, lim),",
			"\t\t   NP = b*P + LP, NQ = b*Q + LQ;",
			"\t\tif (a > b) {",
			"\t\t\t// If b > a/2, we have a semi-convergent that gives us a",
			"\t\t\t// better approximation; if b = a/2, we *may* have one.",
			"\t\t\t// Return {P, Q} here for a more canonical approximation.",
			"\t\t\treturn (abs(x - (d)NP / (d)NQ) < abs(x - (d)P / (d)Q)) ?",
			"\t\t\t\tmake_pair(NP, NQ) : make_pair(P, Q);",
			"\t\t}",
			"\t\tif (abs(y = 1/(y - (d)a)) > 3*N) {",
			"\t\t\treturn {NP, NQ};",
			"\t\t}",
			"\t\tLP = P; P = NP;",
			"\t\tLQ = Q; Q = NQ;",
			"\t}",
			"}",
			"",
			"$0",
		],
	},
	"kactl/number-theory/euclid.h": {
		"scope": "cpp",
		"prefix": "kactl/number-theory/euclid.h",
		"body": [
			"/**",
			" * Author: Unknown",
			" * Date: 2002-09-15",
			" * Source: predates tinyKACTL",
			" * Description: Finds two integers \\$x\\$ and \\$y\\$, such that \\$ax+by=\\gcd(a,b)\\$. If",
			" * you just need gcd, use the built in \\texttt{\\_\\_gcd} instead.",
			" * If \\$a\\$ and \\$b\\$ are coprime, then \\$x\\$ is the inverse of \\$a \\pmod{b}\\$.",
			" */",
			"ll euclid(ll a, ll b, ll &x, ll &y) {",
			"\tif (!b) return x = 1, y = 0, a;",
			"\tll d = euclid(b, a % b, y, x);",
			"\treturn y -= a/b * x, d;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/number-theory/Eratosthenes.h": {
		"scope": "cpp",
		"prefix": "kactl/number-theory/Eratosthenes.h",
		"body": [
			"/**",
			" * Author: H\u00e5kan Terelius",
			" * Date: 2009-08-26",
			" * License: CC0",
			" * Source: http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes",
			" * Description: Prime sieve for generating all primes up to a certain limit. isprime\\$[i]\\$ is true iff \\$i\\$ is a prime.",
			" * Time: lim=100'000'000 \\$\\approx\\$ 0.8 s. Runs 30\\% faster if only odd indices are stored.",
			" * Status: Tested",
			" */",
			"const int MAX_PR = 5'000'000;",
			"bitset<MAX_PR> isprime;",
			"vi eratosthenesSieve(int lim) {",
			"\tisprime.set(); isprime[0] = isprime[1] = 0;",
			"\tfor (int i = 4; i < lim; i += 2) isprime[i] = 0;",
			"\tfor (int i = 3; i*i < lim; i += 2) if (isprime[i])",
			"\t\tfor (int j = i*i; j < lim; j += i*2) isprime[j] = 0;",
			"\tvi pr;",
			"\trep(i,2,lim) if (isprime[i]) pr.push_back(i);",
			"\treturn pr;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/number-theory/Factor.h": {
		"scope": "cpp",
		"prefix": "kactl/number-theory/Factor.h",
		"body": [
			"${1:#include \"ModMulLL.h\"}",
			"${2:#include \"MillerRabin.h\"}",
			"/**",
			" * Author: chilli, SJTU, pajenegod",
			" * Date: 2020-03-04",
			" * License: CC0",
			" * Source: own",
			" * Description: Pollard-rho randomized factorization algorithm. Returns prime",
			" * factors of a number, in arbitrary order (e.g. 2299 -> \\{11, 19, 11\\}).",
			" * Time: \\$O(n^{1/4})\\$, less for numbers with small factors.",
			" * Status: stress-tested",
			" *",
			" * Details: This implementation uses the improvement described here",
			" * (https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm#Variants), where",
			" * one can accumulate gcd calls by some factor (40 chosen here through",
			" * exhaustive testing). This improves performance by approximately 6-10x",
			" * depending on the inputs and speed of gcd. Benchmark found here:",
			" * (https://ideone.com/nGGD9T)",
			" *",
			" * GCD can be improved by a factor of 1.75x using Binary GCD",
			" * (https://lemire.me/blog/2013/12/26/fastest-way-to-compute-the-greatest-common-divisor/).",
			" * However, with the gcd accumulation the bottleneck moves from the gcd calls",
			" * to the modmul. As GCD only constitutes ~12% of runtime, speeding it up",
			" * doesn't matter so much.",
			" *",
			" * This code can probably be sped up by using a faster mod mul - potentially",
			" * montgomery reduction on 128 bit integers.",
			" * Alternatively, one can use a quadratic sieve for an asymptotic improvement,",
			" * which starts being faster in practice around 1e13.",
			" *",
			" * Brent's cycle finding algorithm was tested, but doesn't reduce modmul calls",
			" * significantly.",
			" *",
			" * Subtle implementation notes:",
			" * - prd starts off as 2 to handle the case n = 4; it's harmless for other n",
			" *   since we're guaranteed that n > 2. (Pollard rho has problems with prime",
			" *   powers in general, but all larger ones happen to work.)",
			" * - t starts off as 30 to make the first gcd check come earlier, as an",
			" *   optimization for small numbers.",
			" * - we vary f between restarts because the cycle finding algorithm does not",
			" *   find the first element in the cycle but rather one at distance k*|cycle|",
			" *   from the start, and that can result in continual failures if all cycles",
			" *   have the same size for all prime factors. E.g. fixing f(x) = x^2 + 1 would",
			" *   loop infinitely for n = 352523 * 352817, where all cycles have size 821.",
			" * - we operate on residues in [i, n + i) which modmul is not designed to",
			" *   handle, but specifically modmul(x, x) still turns out to work for small",
			" *   enough i. (With reference to the proof in modmul-proof.tex, the argument",
			" *   for \"S is in [-c, 2c)\" goes through unchanged, while S < 2^63 now follows",
			" *   from S < 2c and S = x^2 (mod c) together implying S < c + i^2.)",
			" */",
			"",
			"ull pollard(ull n) {",
			"\tull x = 0, y = 0, t = 30, prd = 2, i = 1, q;",
			"\tauto f = [&](ull x) { return modmul(x, x, n) + i; };",
			"\twhile (t++ % 40 || __gcd(prd, n) == 1) {",
			"\t\tif (x == y) x = ++i, y = f(x);",
			"\t\tif ((q = modmul(prd, max(x,y) - min(x,y), n))) prd = q;",
			"\t\tx = f(x), y = f(f(y));",
			"\t}",
			"\treturn __gcd(prd, n);",
			"}",
			"vector<ull> factor(ull n) {",
			"\tif (n == 1) return {};",
			"\tif (isPrime(n)) return {n};",
			"\tull x = pollard(n);",
			"\tauto l = factor(x), r = factor(n / x);",
			"\tl.insert(l.end(), all(r));",
			"\treturn l;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/number-theory/phiFunction.h": {
		"scope": "cpp",
		"prefix": "kactl/number-theory/phiFunction.h",
		"body": [
			"/**",
			" * Author: H\u00e5kan Terelius",
			" * Date: 2009-09-25",
			" * License: CC0",
			" * Source: http://en.wikipedia.org/wiki/Euler's_totient_function",
			" * Description: \\emph{Euler's \\$\\phi\\$} function is defined as \\$\\phi(n):=\\#\\$ of positive integers \\$\\leq n\\$ that are coprime with \\$n\\$.",
			" * \\$\\phi(1)=1\\$, \\$p\\$ prime \\$\\Rightarrow \\phi(p^k)=(p-1)p^{k-1}\\$, \\$m,n\\$ coprime \\$\\Rightarrow \\phi(mn)=\\phi(m)\\phi(n)\\$.",
			" * If \\$n=p_1^{k_1}p_2^{k_2} ... p_r^{k_r}\\$ then \\$\\phi(n) = (p_1-1)p_1^{k_1-1}...(p_r-1)p_r^{k_r-1}\\$.",
			" * \\$\\phi(n)=n \\cdot \\prod_{p|n}(1-1/p)\\$.",
			" *",
			" * \\$\\sum_{d|n} \\phi(d) = n\\$, \\$\\sum_{1\\leq k \\leq n, \\gcd(k,n)=1} k = n \\phi(n)/2, n>1\\$",
			" *",
			" * \\textbf{Euler's thm}: \\$a,n\\$ coprime \\$\\Rightarrow a^{\\phi(n)} \\equiv 1 \\pmod{n}\\$.",
			" *",
			" * \\textbf{Fermat's little thm}: \\$p\\$ prime \\$\\Rightarrow a^{p-1} \\equiv 1 \\pmod{p}\\$ \\$\\forall a\\$.",
			" * Status: Tested",
			" */",
			"const int LIM = 5000000;",
			"int phi[LIM];",
			"",
			"void calculatePhi() {",
			"\trep(i,0,LIM) phi[i] = i&1 ? i : i/2;",
			"\tfor (int i = 3; i < LIM; i += 2) if(phi[i] == i)",
			"\t\tfor (int j = i; j < LIM; j += i) phi[j] -= phi[j] / i;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/number-theory/ModPow.h": {
		"scope": "cpp",
		"prefix": "kactl/number-theory/ModPow.h",
		"body": [
			"/**",
			" * Author: Noam527",
			" * Date: 2019-04-24",
			" * License: CC0",
			" * Source: folklore",
			" * Description:",
			" * Status: tested",
			" */",
			"const ll mod = 1000000007; // faster if const",
			"",
			"ll modpow(ll b, ll e) {",
			"\tll ans = 1;",
			"\tfor (; e; b = b * b % mod, e /= 2)",
			"\t\tif (e & 1) ans = ans * b % mod;",
			"\treturn ans;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/number-theory/ModSum.h": {
		"scope": "cpp",
		"prefix": "kactl/number-theory/ModSum.h",
		"body": [
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2015-06-23",
			" * License: CC0",
			" * Source: own work",
			" * Description: Sums of mod'ed arithmetic progressions.",
			" *",
			" * \\texttt{modsum(to, c, k, m)} = \\$\\sum_{i=0}^{\\mathrm{to}-1}{(ki+c) \\% m}\\$.",
			" * \\texttt{divsum} is similar but for floored division.",
			" * Time: \\$\\log(m)\\$, with a large constant.",
			" * Status: Tested for all |k|,|c|,to,m <= 50, and on kattis:aladin",
			" */",
			"typedef unsigned long long ull;",
			"ull sumsq(ull to) { return to / 2 * ((to-1) | 1); }",
			"/// ^ written in a weird way to deal with overflows correctly",
			"",
			"ull divsum(ull to, ull c, ull k, ull m) {",
			"\tull res = k / m * sumsq(to) + c / m * to;",
			"\tk %= m; c %= m;",
			"\tif (!k) return res;",
			"\tull to2 = (to * k + c) / m;",
			"\treturn res + (to - 1) * to2 - divsum(to2, m-1 - c, m, k);",
			"}",
			"",
			"ll modsum(ull to, ll c, ll k, ll m) {",
			"\tc = ((c % m) + m) % m;",
			"\tk = ((k % m) + m) % m;",
			"\treturn to * c + k * sumsq(to) - m * divsum(to, c, k, m);",
			"}",
			"",
			"$0",
		],
	},
	"kactl/numerical/Tridiagonal.h": {
		"scope": "cpp",
		"prefix": "kactl/numerical/Tridiagonal.h",
		"body": [
			"/**",
			" * Author: Ulf Lundstrom, Simon Lindholm",
			" * Date: 2009-08-15",
			" * License: CC0",
			" * Source: https://en.wikipedia.org/wiki/Tridiagonal_matrix_algorithm",
			" * Description: \\$x=\\textrm{tridiagonal}(d,p,q,b)\\$ solves the equation system",
			"\\[",
			"\\left(\\begin{array}{c}b_0\\\\b_1\\\\b_2\\\\b_3\\\\\\vdots\\\\b_{n-1}\\end{array}\\right) =",
			"\\left(\\begin{array}{cccccc}",
			"d_0 & p_0 & 0 & 0 & \\cdots & 0\\\\",
			"q_0 & d_1 & p_1 & 0 & \\cdots & 0\\\\",
			"0 & q_1 & d_2 & p_2 & \\cdots & 0\\\\",
			"\\vdots & \\vdots & \\ddots & \\ddots & \\ddots & \\vdots\\\\",
			"0 & 0 & \\cdots & q_{n-3} & d_{n-2} & p_{n-2}\\\\",
			"0 & 0 & \\cdots & 0 & q_{n-2} & d_{n-1}\\\\",
			"\\end{array}\\right)",
			"\\left(\\begin{array}{c}x_0\\\\x_1\\\\x_2\\\\x_3\\\\\\vdots\\\\x_{n-1}\\end{array}\\right).",
			"\\]",
			"",
			"This is useful for solving problems on the type",
			"\\[ a_i=b_ia_{i-1}+c_ia_{i+1}+d_i,\\,1\\leq i\\leq n, \\]",
			"where \\$a_0\\$, \\$a_{n+1}\\$, \\$b_i\\$, \\$c_i\\$ and \\$d_i\\$ are known. \\$a\\$ can then be obtained from",
			"\\begin{align*}",
			"\\{a_i\\}=\\textrm{tridiagonal}(&\\{1,-1,-1,...,-1,1\\}, \\{0,c_1,c_2,\\dots,c_n\\},\\\\",
			"&\\{b_1,b_2,\\dots,b_n,0\\}, \\{a_0,d_1,d_2,\\dots,d_n,a_{n+1}\\}).",
			"\\end{align*}",
			"Fails if the solution is not unique.",
			"",
			"If \\$|d_i| > |p_i| + |q_{i-1}|\\$ for all \\$i\\$, or \\$|d_i| > |p_{i-1}| + |q_i|\\$, or the matrix is positive definite,",
			"the algorithm is numerically stable and neither \\texttt{tr} nor the check for \\texttt{diag[i] == 0} is needed.",
			" * Time: O(N)",
			" * Status: Brute-force tested mod 5 and 7 and stress-tested for real matrices obeying the criteria above.",
			" */",
			"typedef double T;",
			"vector<T> tridiagonal(vector<T> diag, const vector<T>& super,",
			"\t\tconst vector<T>& sub, vector<T> b) {",
			"\tint n = sz(b); vi tr(n);",
			"\trep(i,0,n-1) {",
			"\t\tif (abs(diag[i]) < 1e-9 * abs(super[i])) { // diag[i] == 0",
			"\t\t\tb[i+1] -= b[i] * diag[i+1] / super[i];",
			"\t\t\tif (i+2 < n) b[i+2] -= b[i] * sub[i+1] / super[i];",
			"\t\t\tdiag[i+1] = sub[i]; tr[++i] = 1;",
			"\t\t} else {",
			"\t\t\tdiag[i+1] -= super[i]*sub[i]/diag[i];",
			"\t\t\tb[i+1] -= b[i]*sub[i]/diag[i];",
			"\t\t}",
			"\t}",
			"\tfor (int i = n; i--;) {",
			"\t\tif (tr[i]) {",
			"\t\t\tswap(b[i], b[i-1]);",
			"\t\t\tdiag[i-1] = diag[i];",
			"\t\t\tb[i] /= super[i-1];",
			"\t\t} else {",
			"\t\t\tb[i] /= diag[i];",
			"\t\t\tif (i) b[i-1] -= b[i]*super[i-1];",
			"\t\t}",
			"\t}",
			"\treturn b;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/numerical/Polynomial.h": {
		"scope": "cpp",
		"prefix": "kactl/numerical/Polynomial.h",
		"body": [
			"/**",
			" * Author: David Rydh, Per Austrin",
			" * Date: 2003-03-16",
			" * Description:",
			" */",
			"struct Poly {",
			"\tvector<double> a;",
			"\tdouble operator()(double x) const {",
			"\t\tdouble val = 0;",
			"\t\tfor (int i = sz(a); i--;) (val *= x) += a[i];",
			"\t\treturn val;",
			"\t}",
			"\tvoid diff() {",
			"\t\trep(i,1,sz(a)) a[i-1] = i*a[i];",
			"\t\ta.pop_back();",
			"\t}",
			"\tvoid divroot(double x0) {",
			"\t\tdouble b = a.back(), c; a.back() = 0;",
			"\t\tfor(int i=sz(a)-1; i--;) c = a[i], a[i] = a[i+1]*x0+b, b=c;",
			"\t\ta.pop_back();",
			"\t}",
			"};",
			"",
			"$0",
		],
	},
	"kactl/numerical/FastFourierTransform.h": {
		"scope": "cpp",
		"prefix": "kactl/numerical/FastFourierTransform.h",
		"body": [
			"/**",
			" * Author: Ludo Pulles, chilli, Simon Lindholm",
			" * Date: 2019-01-09",
			" * License: CC0",
			" * Source: http://neerc.ifmo.ru/trains/toulouse/2017/fft2.pdf (do read, it's excellent)",
			"   Accuracy bound from http://www.daemonology.net/papers/fft.pdf",
			" * Description: fft(a) computes \\$\\hat f(k) = \\sum_x a[x] \\exp(2\\pi i \\cdot k x / N)\\$ for all \\$k\\$. N must be a power of 2.",
			"   Useful for convolution:",
			"   \\texttt{conv(a, b) = c}, where \\$c[x] = \\sum a[i]b[x-i]\\$.",
			"   For convolution of complex numbers or more than two vectors: FFT, multiply",
			"   pointwise, divide by n, reverse(start+1, end), FFT back.",
			"   Rounding is safe if \\$(\\sum a_i^2 + \\sum b_i^2)\\log_2{N} < 9\\cdot10^{14}\\$",
			"   (in practice \\$10^{16}\\$; higher for random inputs).",
			"   Otherwise, use NTT/FFTMod.",
			" * Time: O(N \\log N) with \\$N = |A|+|B|\\$ (\\$\\tilde 1s\\$ for \\$N=2^{22}\\$)",
			" * Status: somewhat tested",
			" * Details: An in-depth examination of precision for both FFT and FFTMod can be found",
			" * here (https://github.com/simonlindholm/fft-precision/blob/master/fft-precision.md)",
			" */",
			"typedef complex<double> C;",
			"typedef vector<double> vd;",
			"void fft(vector<C>& a) {",
			"\tint n = sz(a), L = 31 - __builtin_clz(n);",
			"\tstatic vector<complex<long double>> R(2, 1);",
			"\tstatic vector<C> rt(2, 1);  // (^ 10% faster if double)",
			"\tfor (static int k = 2; k < n; k *= 2) {",
			"\t\tR.resize(n); rt.resize(n);",
			"\t\tauto x = polar(1.0L, acos(-1.0L) / k);",
			"\t\trep(i,k,2*k) rt[i] = R[i] = i&1 ? R[i/2] * x : R[i/2];",
			"\t}",
			"\tvi rev(n);",
			"\trep(i,0,n) rev[i] = (rev[i / 2] | (i & 1) << L) / 2;",
			"\trep(i,0,n) if (i < rev[i]) swap(a[i], a[rev[i]]);",
			"\tfor (int k = 1; k < n; k *= 2)",
			"\t\tfor (int i = 0; i < n; i += 2 * k) rep(j,0,k) {",
			"\t\t\t// C z = rt[j+k] * a[i+j+k]; // (25% faster if hand-rolled)  /// include-line",
			"\t\t\tauto x = (double *)&rt[j+k], y = (double *)&a[i+j+k];        /// exclude-line",
			"\t\t\tC z(x[0]*y[0] - x[1]*y[1], x[0]*y[1] + x[1]*y[0]);           /// exclude-line",
			"\t\t\ta[i + j + k] = a[i + j] - z;",
			"\t\t\ta[i + j] += z;",
			"\t\t}",
			"}",
			"vd conv(const vd& a, const vd& b) {",
			"\tif (a.empty() || b.empty()) return {};",
			"\tvd res(sz(a) + sz(b) - 1);",
			"\tint L = 32 - __builtin_clz(sz(res)), n = 1 << L;",
			"\tvector<C> in(n), out(n);",
			"\tcopy(all(a), begin(in));",
			"\trep(i,0,sz(b)) in[i].imag(b[i]);",
			"\tfft(in);",
			"\tfor (C& x : in) x *= x;",
			"\trep(i,0,n) out[i] = in[-i & (n - 1)] - conj(in[i]);",
			"\tfft(out);",
			"\trep(i,0,sz(res)) res[i] = imag(out[i]) / (4 * n);",
			"\treturn res;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/numerical/MatrixInverse.h": {
		"scope": "cpp",
		"prefix": "kactl/numerical/MatrixInverse.h",
		"body": [
			"/**",
			" * Author: Max Bennedich",
			" * Date: 2004-02-08",
			" * Description: Invert matrix \\$A\\$. Returns rank; result is stored in \\$A\\$ unless singular (rank < n).",
			" * Can easily be extended to prime moduli; for prime powers, repeatedly",
			" * set \\$A^{-1} = A^{-1} (2I - AA^{-1})\\  (\\text{mod }p^k)\\$ where \\$A^{-1}\\$ starts as",
			" * the inverse of A mod p, and k is doubled in each step.",
			" * Time: O(n^3)",
			" * Status: Slightly tested",
			" */",
			"int matInv(vector<vector<double>>& A) {",
			"\tint n = sz(A); vi col(n);",
			"\tvector<vector<double>> tmp(n, vector<double>(n));",
			"\trep(i,0,n) tmp[i][i] = 1, col[i] = i;",
			"",
			"\trep(i,0,n) {",
			"\t\tint r = i, c = i;",
			"\t\trep(j,i,n) rep(k,i,n)",
			"\t\t\tif (fabs(A[j][k]) > fabs(A[r][c]))",
			"\t\t\t\tr = j, c = k;",
			"\t\tif (fabs(A[r][c]) < 1e-12) return i;",
			"\t\tA[i].swap(A[r]); tmp[i].swap(tmp[r]);",
			"\t\trep(j,0,n)",
			"\t\t\tswap(A[j][i], A[j][c]), swap(tmp[j][i], tmp[j][c]);",
			"\t\tswap(col[i], col[c]);",
			"\t\tdouble v = A[i][i];",
			"\t\trep(j,i+1,n) {",
			"\t\t\tdouble f = A[j][i] / v;",
			"\t\t\tA[j][i] = 0;",
			"\t\t\trep(k,i+1,n) A[j][k] -= f*A[i][k];",
			"\t\t\trep(k,0,n) tmp[j][k] -= f*tmp[i][k];",
			"\t\t}",
			"\t\trep(j,i+1,n) A[i][j] /= v;",
			"\t\trep(j,0,n) tmp[i][j] /= v;",
			"\t\tA[i][i] = 1;",
			"\t}",
			"",
			"\t/// forget A at this point, just eliminate tmp backward",
			"\tfor (int i = n-1; i > 0; --i) rep(j,0,i) {",
			"\t\tdouble v = A[j][i];",
			"\t\trep(k,0,n) tmp[j][k] -= v*tmp[i][k];",
			"\t}",
			"",
			"\trep(i,0,n) rep(j,0,n) A[col[i]][col[j]] = tmp[i][j];",
			"\treturn n;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/numerical/LinearRecurrence.h": {
		"scope": "cpp",
		"prefix": "kactl/numerical/LinearRecurrence.h",
		"body": [
			"/**",
			" * Author: Lucian Bicsi",
			" * Date: 2018-02-14",
			" * License: CC0",
			" * Source: Chinese material",
			" * Description: Generates the \\$k\\$'th term of an \\$n\\$-order",
			" * linear recurrence \\$S[i] = \\sum_j S[i-j-1]tr[j]\\$,",
			" * given \\$S[0 \\ldots \\ge n-1]\\$ and \\$tr[0 \\ldots n-1]\\$.",
			" * Faster than matrix multiplication.",
			" * Useful together with Berlekamp--Massey.",
			" * Usage: linearRec({0, 1}, {1, 1}, k) // k'th Fibonacci number",
			" * Time: O(n^2 \\log k)",
			" * Status: bruteforce-tested mod 5 for n <= 5",
			" */",
			"const ll mod = 5; /** exclude-line */",
			"",
			"typedef vector<ll> Poly;",
			"ll linearRec(Poly S, Poly tr, ll k) {",
			"\tint n = sz(tr);",
			"",
			"\tauto combine = [&](Poly a, Poly b) {",
			"\t\tPoly res(n * 2 + 1);",
			"\t\trep(i,0,n+1) rep(j,0,n+1)",
			"\t\t\tres[i + j] = (res[i + j] + a[i] * b[j]) % mod;",
			"\t\tfor (int i = 2 * n; i > n; --i) rep(j,0,n)",
			"\t\t\tres[i - 1 - j] = (res[i - 1 - j] + res[i] * tr[j]) % mod;",
			"\t\tres.resize(n + 1);",
			"\t\treturn res;",
			"\t};",
			"",
			"\tPoly pol(n + 1), e(pol);",
			"\tpol[0] = e[1] = 1;",
			"",
			"\tfor (++k; k; k /= 2) {",
			"\t\tif (k % 2) pol = combine(pol, e);",
			"\t\te = combine(e, e);",
			"\t}",
			"",
			"\tll res = 0;",
			"\trep(i,0,n) res = (res + pol[i + 1] * S[i]) % mod;",
			"\treturn res;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/numerical/IntegrateAdaptive.h": {
		"scope": "cpp",
		"prefix": "kactl/numerical/IntegrateAdaptive.h",
		"body": [
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2015-02-11",
			" * License: CC0",
			" * Source: Wikipedia",
			" * Description: Fast integration using an adaptive Simpson's rule.",
			" * Usage:",
			"\tdouble sphereVolume = quad(-1, 1, [](double x) {",
			"\treturn quad(-1, 1, [\\&](double y) {",
			"\treturn quad(-1, 1, [\\&](double z) {",
			"\treturn x*x + y*y + z*z < 1; });});});",
			" * Status: mostly untested",
			" */",
			"typedef double d;",
			"#define S(a,b) (f(a) + 4*f((a+b) / 2) + f(b)) * (b-a) / 6",
			"",
			"template <class F>",
			"d rec(F& f, d a, d b, d eps, d S) {",
			"\td c = (a + b) / 2;",
			"\td S1 = S(a, c), S2 = S(c, b), T = S1 + S2;",
			"\tif (abs(T - S) <= 15 * eps || b - a < 1e-10)",
			"\t\treturn T + (T - S) / 15;",
			"\treturn rec(f, a, c, eps / 2, S1) + rec(f, c, b, eps / 2, S2);",
			"}",
			"template<class F>",
			"d quad(d a, d b, F f, d eps = 1e-8) {",
			"\treturn rec(f, a, b, eps, S(a, b));",
			"}",
			"",
			"$0",
		],
	},
	"kactl/numerical/IntDeterminant.h": {
		"scope": "cpp",
		"prefix": "kactl/numerical/IntDeterminant.h",
		"body": [
			"/**",
			" * Author: Unknown",
			" * Date: 2014-11-27",
			" * Source: somewhere on github",
			" * Description: Calculates determinant using modular arithmetics.",
			" * Modulos can also be removed to get a pure-integer version.",
			" * Time: \\$O(N^3)\\$",
			" * Status: bruteforce-tested for N <= 3, mod <= 7",
			" */",
			"const ll mod = 12345;",
			"ll det(vector<vector<ll>>& a) {",
			"\tint n = sz(a); ll ans = 1;",
			"\trep(i,0,n) {",
			"\t\trep(j,i+1,n) {",
			"\t\t\twhile (a[j][i] != 0) { // gcd step",
			"\t\t\t\tll t = a[i][i] / a[j][i];",
			"\t\t\t\tif (t) rep(k,i,n)",
			"\t\t\t\t\ta[i][k] = (a[i][k] - a[j][k] * t) % mod;",
			"\t\t\t\tswap(a[i], a[j]);",
			"\t\t\t\tans *= -1;",
			"\t\t\t}",
			"\t\t}",
			"\t\tans = ans * a[i][i] % mod;",
			"\t\tif (!ans) return 0;",
			"\t}",
			"\treturn (ans + mod) % mod;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/numerical/BerlekampMassey.h": {
		"scope": "cpp",
		"prefix": "kactl/numerical/BerlekampMassey.h",
		"body": [
			"${1:#include \"../number-theory/ModPow.h\"}",
			"/**",
			" * Author: Lucian Bicsi",
			" * Date: 2017-10-31",
			" * License: CC0",
			" * Source: Wikipedia",
			" * Description: Recovers any \\$n\\$-order linear recurrence relation from the first",
			" * \\$2n\\$ terms of the recurrence.",
			" * Useful for guessing linear recurrences after brute-forcing the first terms.",
			" * Should work on any field, but numerical stability for floats is not guaranteed.",
			" * Output will have size \\$\\le n\\$.",
			" * Usage: berlekampMassey({0, 1, 1, 3, 5, 11}) // {1, 2}",
			" * Time: O(N^2)",
			" * Status: bruteforce-tested mod 5 for n <= 5 and all s",
			" */",
			"",
			"vector<ll> berlekampMassey(vector<ll> s) {",
			"\tint n = sz(s), L = 0, m = 0;",
			"\tvector<ll> C(n), B(n), T;",
			"\tC[0] = B[0] = 1;",
			"",
			"\tll b = 1;",
			"\trep(i,0,n) { ++m;",
			"\t\tll d = s[i] % mod;",
			"\t\trep(j,1,L+1) d = (d + C[j] * s[i - j]) % mod;",
			"\t\tif (!d) continue;",
			"\t\tT = C; ll coef = d * modpow(b, mod-2) % mod;",
			"\t\trep(j,m,n) C[j] = (C[j] - coef * B[j - m]) % mod;",
			"\t\tif (2 * L > i) continue;",
			"\t\tL = i + 1 - L; B = T; b = d; m = 0;",
			"\t}",
			"",
			"\tC.resize(L + 1); C.erase(C.begin());",
			"\tfor (ll& x : C) x = (mod - x) % mod;",
			"\treturn C;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/numerical/SolveLinear.h": {
		"scope": "cpp",
		"prefix": "kactl/numerical/SolveLinear.h",
		"body": [
			"/**",
			" * Author: Per Austrin, Simon Lindholm",
			" * Date: 2004-02-08",
			" * License: CC0",
			" * Description: Solves \\$A * x = b\\$. If there are multiple solutions, an arbitrary one is returned.",
			" *  Returns rank, or -1 if no solutions. Data in \\$A\\$ and \\$b\\$ is lost.",
			" * Time: O(n^2 m)",
			" * Status: tested on kattis:equationsolver, and bruteforce-tested mod 3 and 5 for n,m <= 3",
			" */",
			"typedef vector<double> vd;",
			"const double eps = 1e-12;",
			"",
			"int solveLinear(vector<vd>& A, vd& b, vd& x) {",
			"\tint n = sz(A), m = sz(x), rank = 0, br, bc;",
			"\tif (n) assert(sz(A[0]) == m);",
			"\tvi col(m); iota(all(col), 0);",
			"",
			"\trep(i,0,n) {",
			"\t\tdouble v, bv = 0;",
			"\t\trep(r,i,n) rep(c,i,m)",
			"\t\t\tif ((v = fabs(A[r][c])) > bv)",
			"\t\t\t\tbr = r, bc = c, bv = v;",
			"\t\tif (bv <= eps) {",
			"\t\t\trep(j,i,n) if (fabs(b[j]) > eps) return -1;",
			"\t\t\tbreak;",
			"\t\t}",
			"\t\tswap(A[i], A[br]);",
			"\t\tswap(b[i], b[br]);",
			"\t\tswap(col[i], col[bc]);",
			"\t\trep(j,0,n) swap(A[j][i], A[j][bc]);",
			"\t\tbv = 1/A[i][i];",
			"\t\trep(j,i+1,n) {",
			"\t\t\tdouble fac = A[j][i] * bv;",
			"\t\t\tb[j] -= fac * b[i];",
			"\t\t\trep(k,i+1,m) A[j][k] -= fac*A[i][k];",
			"\t\t}",
			"\t\trank++;",
			"\t}",
			"",
			"\tx.assign(m, 0);",
			"\tfor (int i = rank; i--;) {",
			"\t\tb[i] /= A[i][i];",
			"\t\tx[col[i]] = b[i];",
			"\t\trep(j,0,i) b[j] -= A[j][i] * b[i];",
			"\t}",
			"\treturn rank; // (multiple solutions if rank < m)",
			"}",
			"",
			"$0",
		],
	},
	"kactl/numerical/FastFourierTransformMod.h": {
		"scope": "cpp",
		"prefix": "kactl/numerical/FastFourierTransformMod.h",
		"body": [
			"${1:#include \"FastFourierTransform.h\"}",
			"/**",
			" * Author: chilli",
			" * Date: 2019-04-25",
			" * License: CC0",
			" * Source: http://neerc.ifmo.ru/trains/toulouse/2017/fft2.pdf",
			" * Description: Higher precision FFT, can be used for convolutions modulo arbitrary integers",
			" * as long as \\$N\\log_2N\\cdot \\text{mod} < 8.6 \\cdot 10^{14}\\$ (in practice \\$10^{16}\\$ or higher).",
			" * Inputs must be in \\$[0, \\text{mod})\\$.",
			" * Time: O(N \\log N), where \\$N = |A|+|B|\\$ (twice as slow as NTT or FFT)",
			" * Status: stress-tested",
			" * Details: An in-depth examination of precision for both FFT and FFTMod can be found",
			" * here (https://github.com/simonlindholm/fft-precision/blob/master/fft-precision.md)",
			" */",
			"",
			"typedef vector<ll> vl;",
			"template<int M> vl convMod(const vl &a, const vl &b) {",
			"\tif (a.empty() || b.empty()) return {};",
			"\tvl res(sz(a) + sz(b) - 1);",
			"\tint B=32-__builtin_clz(sz(res)), n=1<<B, cut=int(sqrt(M));",
			"\tvector<C> L(n), R(n), outs(n), outl(n);",
			"\trep(i,0,sz(a)) L[i] = C((int)a[i] / cut, (int)a[i] % cut);",
			"\trep(i,0,sz(b)) R[i] = C((int)b[i] / cut, (int)b[i] % cut);",
			"\tfft(L), fft(R);",
			"\trep(i,0,n) {",
			"\t\tint j = -i & (n - 1);",
			"\t\toutl[j] = (L[i] + conj(L[j])) * R[i] / (2.0 * n);",
			"\t\touts[j] = (L[i] - conj(L[j])) * R[i] / (2.0 * n) / 1i;",
			"\t}",
			"\tfft(outl), fft(outs);",
			"\trep(i,0,sz(res)) {",
			"\t\tll av = ll(real(outl[i])+.5), cv = ll(imag(outs[i])+.5);",
			"\t\tll bv = ll(imag(outl[i])+.5) + ll(real(outs[i])+.5);",
			"\t\tres[i] = ((av % M * cut + bv) % M * cut + cv) % M;",
			"\t}",
			"\treturn res;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/numerical/HillClimbing.h": {
		"scope": "cpp",
		"prefix": "kactl/numerical/HillClimbing.h",
		"body": [
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2015-02-04",
			" * License: CC0",
			" * Source: Johan Sannemo",
			" * Description: Poor man's optimization for unimodal functions.",
			" * Status: used with great success",
			" */",
			"typedef array<double, 2> P;",
			"",
			"template<class F> pair<double, P> hillClimb(P start, F f) {",
			"\tpair<double, P> cur(f(start), start);",
			"\tfor (double jmp = 1e9; jmp > 1e-20; jmp /= 2) {",
			"\t\trep(j,0,100) rep(dx,-1,2) rep(dy,-1,2) {",
			"\t\t\tP p = cur.second;",
			"\t\t\tp[0] += dx*jmp;",
			"\t\t\tp[1] += dy*jmp;",
			"\t\t\tcur = min(cur, make_pair(f(p), p));",
			"\t\t}",
			"\t}",
			"\treturn cur;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/numerical/SolveLinearBinary.h": {
		"scope": "cpp",
		"prefix": "kactl/numerical/SolveLinearBinary.h",
		"body": [
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2016-08-27",
			" * License: CC0",
			" * Source: own work",
			" * Description: Solves \\$Ax = b\\$ over \\$\\mathbb F_2\\$. If there are multiple solutions, one is returned arbitrarily.",
			" *  Returns rank, or -1 if no solutions. Destroys \\$A\\$ and \\$b\\$.",
			" * Time: O(n^2 m)",
			" * Status: bruteforce-tested for n, m <= 4",
			" */",
			"typedef bitset<1000> bs;",
			"",
			"int solveLinear(vector<bs>& A, vi& b, bs& x, int m) {",
			"\tint n = sz(A), rank = 0, br;",
			"\tassert(m <= sz(x));",
			"\tvi col(m); iota(all(col), 0);",
			"\trep(i,0,n) {",
			"\t\tfor (br=i; br<n; ++br) if (A[br].any()) break;",
			"\t\tif (br == n) {",
			"\t\t\trep(j,i,n) if(b[j]) return -1;",
			"\t\t\tbreak;",
			"\t\t}",
			"\t\tint bc = (int)A[br]._Find_next(i-1);",
			"\t\tswap(A[i], A[br]);",
			"\t\tswap(b[i], b[br]);",
			"\t\tswap(col[i], col[bc]);",
			"\t\trep(j,0,n) if (A[j][i] != A[j][bc]) {",
			"\t\t\tA[j].flip(i); A[j].flip(bc);",
			"\t\t}",
			"\t\trep(j,i+1,n) if (A[j][i]) {",
			"\t\t\tb[j] ^= b[i];",
			"\t\t\tA[j] ^= A[i];",
			"\t\t}",
			"\t\trank++;",
			"\t}",
			"",
			"\tx = bs();",
			"\tfor (int i = rank; i--;) {",
			"\t\tif (!b[i]) continue;",
			"\t\tx[col[i]] = 1;",
			"\t\trep(j,0,i) b[j] ^= A[j][i];",
			"\t}",
			"\treturn rank; // (multiple solutions if rank < m)",
			"}",
			"",
			"$0",
		],
	},
	"kactl/numerical/Integrate.h": {
		"scope": "cpp",
		"prefix": "kactl/numerical/Integrate.h",
		"body": [
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2015-02-11",
			" * License: CC0",
			" * Source: Wikipedia",
			" * Description: Simple integration of a function over an interval using",
			" *  Simpson's rule. The error should be proportional to \\$h^4\\$, although in",
			" *  practice you will want to verify that the result is stable to desired",
			" *  precision when epsilon changes.",
			" * Status: mostly untested",
			" */",
			"template<class F>",
			"double quad(double a, double b, F f, const int n = 1000) {",
			"\tdouble h = (b - a) / 2 / n, v = f(a) + f(b);",
			"\trep(i,1,n*2)",
			"\t\tv += f(a + i*h) * (i&1 ? 4 : 2);",
			"\treturn v * h / 3;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/numerical/GoldenSectionSearch.h": {
		"scope": "cpp",
		"prefix": "kactl/numerical/GoldenSectionSearch.h",
		"body": [
			"/**",
			" * Author: Ulf Lundstrom",
			" * Date: 2009-04-17",
			" * License: CC0",
			" * Source: Numeriska algoritmer med matlab, Gerd Eriksson, NADA, KTH",
			" * Description: Finds the argument minimizing the function \\$f\\$ in the interval \\$[a,b]\\$",
			" * assuming \\$f\\$ is unimodal on the interval, i.e. has only one local minimum and no local",
			" * maximum. The maximum error in the result is \\$eps\\$. Works equally well for maximization",
			" * with a small change in the code. See TernarySearch.h in the Various chapter for a",
			" * discrete version.",
			" * Usage:",
			"\tdouble func(double x) { return 4+x+.3*x*x; }",
			"\tdouble xmin = gss(-1000,1000,func);",
			" * Time: O(\\log((b-a) / \\epsilon))",
			" * Status: tested",
			" */",
			"/// It is important for r to be precise, otherwise we don't necessarily maintain the inequality a < x1 < x2 < b.",
			"double gss(double a, double b, double (*f)(double)) {",
			"\tdouble r = (sqrt(5)-1)/2, eps = 1e-7;",
			"\tdouble x1 = b - r*(b-a), x2 = a + r*(b-a);",
			"\tdouble f1 = f(x1), f2 = f(x2);",
			"\twhile (b-a > eps)",
			"\t\tif (f1 < f2) { //change to > to find maximum",
			"\t\t\tb = x2; x2 = x1; f2 = f1;",
			"\t\t\tx1 = b - r*(b-a); f1 = f(x1);",
			"\t\t} else {",
			"\t\t\ta = x1; x1 = x2; f1 = f2;",
			"\t\t\tx2 = a + r*(b-a); f2 = f(x2);",
			"\t\t}",
			"\treturn a;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/numerical/PolyInterpolate.h": {
		"scope": "cpp",
		"prefix": "kactl/numerical/PolyInterpolate.h",
		"body": [
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2017-05-10",
			" * License: CC0",
			" * Source: Wikipedia",
			" * Description: Given \\$n\\$ points (x[i], y[i]), computes an n-1-degree polynomial \\$p\\$ that",
			" *  passes through them: \\$p(x) = a[0]*x^0 + ... + a[n-1]*x^{n-1}\\$.",
			" *  For numerical precision, pick \\$x[k] = c*\\cos(k/(n-1)*\\pi), k=0 \\dots n-1\\$.",
			" * Time: O(n^2)",
			" */",
			"typedef vector<double> vd;",
			"vd interpolate(vd x, vd y, int n) {",
			"\tvd res(n), temp(n);",
			"\trep(k,0,n-1) rep(i,k+1,n)",
			"\t\ty[i] = (y[i] - y[k]) / (x[i] - x[k]);",
			"\tdouble last = 0; temp[0] = 1;",
			"\trep(k,0,n) rep(i,0,n) {",
			"\t\tres[i] += y[k] * temp[i];",
			"\t\tswap(last, temp[i]);",
			"\t\ttemp[i] -= last * x[k];",
			"\t}",
			"\treturn res;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/numerical/Determinant.h": {
		"scope": "cpp",
		"prefix": "kactl/numerical/Determinant.h",
		"body": [
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2016-09-06",
			" * License: CC0",
			" * Source: folklore",
			" * Description: Calculates determinant of a matrix. Destroys the matrix.",
			" * Time: \\$O(N^3)\\$",
			" * Status: somewhat tested",
			" */",
			"double det(vector<vector<double>>& a) {",
			"\tint n = sz(a); double res = 1;",
			"\trep(i,0,n) {",
			"\t\tint b = i;",
			"\t\trep(j,i+1,n) if (fabs(a[j][i]) > fabs(a[b][i])) b = j;",
			"\t\tif (i != b) swap(a[i], a[b]), res *= -1;",
			"\t\tres *= a[i][i];",
			"\t\tif (res == 0) return 0;",
			"\t\trep(j,i+1,n) {",
			"\t\t\tdouble v = a[j][i] / a[i][i];",
			"\t\t\tif (v != 0) rep(k,i+1,n) a[j][k] -= v * a[i][k];",
			"\t\t}",
			"\t}",
			"\treturn res;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/numerical/SolveLinear2.h": {
		"scope": "cpp",
		"prefix": "kactl/numerical/SolveLinear2.h",
		"body": [
			"${1:#include \"SolveLinear.h\"}",
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2016-09-06",
			" * License: CC0",
			" * Source: me",
			" * Description: To get all uniquely determined values of \\$x\\$ back from SolveLinear, make the following changes:",
			" * Status: tested on kattis:equationsolverplus, stress-tested",
			" */",
			"",
			"rep(j,0,n) if (j != i) // instead of rep(j,i+1,n)",
			"// ... then at the end:",
			"x.assign(m, undefined);",
			"rep(i,0,rank) {",
			"\trep(j,rank,m) if (fabs(A[i][j]) > eps) goto fail;",
			"\tx[col[i]] = b[i] / A[i][i];",
			"fail:; }",
			"",
			"$0",
		],
	},
	"kactl/numerical/Simplex.h": {
		"scope": "cpp",
		"prefix": "kactl/numerical/Simplex.h",
		"body": [
			"/**",
			" * Author: Stanford",
			" * Source: Stanford Notebook",
			" * License: MIT",
			" * Description: Solves a general linear maximization problem: maximize \\$c^T x\\$ subject to \\$Ax \\le b\\$, \\$x \\ge 0\\$.",
			" * Returns -inf if there is no solution, inf if there are arbitrarily good solutions, or the maximum value of \\$c^T x\\$ otherwise.",
			" * The input vector is set to an optimal \\$x\\$ (or in the unbounded case, an arbitrary solution fulfilling the constraints).",
			" * Numerical stability is not guaranteed. For better performance, define variables such that \\$x = 0\\$ is viable.",
			" * Usage:",
			" * vvd A = {{1,-1}, {-1,1}, {-1,-2}};",
			" * vd b = {1,1,-4}, c = {-1,-1}, x;",
			" * T val = LPSolver(A, b, c).solve(x);",
			" * Time: O(NM * \\#pivots), where a pivot may be e.g. an edge relaxation. O(2^n) in the general case.",
			" * Status: seems to work?",
			" */",
			"typedef double T; // long double, Rational, double + mod<P>...",
			"typedef vector<T> vd;",
			"typedef vector<vd> vvd;",
			"",
			"const T eps = 1e-8, inf = 1/.0;",
			"#define MP make_pair",
			"#define ltj(X) if(s == -1 || MP(X[j],N[j]) < MP(X[s],N[s])) s=j",
			"",
			"struct LPSolver {",
			"\tint m, n;",
			"\tvi N, B;",
			"\tvvd D;",
			"",
			"\tLPSolver(const vvd& A, const vd& b, const vd& c) :",
			"\t\tm(sz(b)), n(sz(c)), N(n+1), B(m), D(m+2, vd(n+2)) {",
			"\t\t\trep(i,0,m) rep(j,0,n) D[i][j] = A[i][j];",
			"\t\t\trep(i,0,m) { B[i] = n+i; D[i][n] = -1; D[i][n+1] = b[i];}",
			"\t\t\trep(j,0,n) { N[j] = j; D[m][j] = -c[j]; }",
			"\t\t\tN[n] = -1; D[m+1][n] = 1;",
			"\t\t}",
			"",
			"\tvoid pivot(int r, int s) {",
			"\t\tT *a = D[r].data(), inv = 1 / a[s];",
			"\t\trep(i,0,m+2) if (i != r && abs(D[i][s]) > eps) {",
			"\t\t\tT *b = D[i].data(), inv2 = b[s] * inv;",
			"\t\t\trep(j,0,n+2) b[j] -= a[j] * inv2;",
			"\t\t\tb[s] = a[s] * inv2;",
			"\t\t}",
			"\t\trep(j,0,n+2) if (j != s) D[r][j] *= inv;",
			"\t\trep(i,0,m+2) if (i != r) D[i][s] *= -inv;",
			"\t\tD[r][s] = inv;",
			"\t\tswap(B[r], N[s]);",
			"\t}",
			"",
			"\tbool simplex(int phase) {",
			"\t\tint x = m + phase - 1;",
			"\t\tfor (;;) {",
			"\t\t\tint s = -1;",
			"\t\t\trep(j,0,n+1) if (N[j] != -phase) ltj(D[x]);",
			"\t\t\tif (D[x][s] >= -eps) return true;",
			"\t\t\tint r = -1;",
			"\t\t\trep(i,0,m) {",
			"\t\t\t\tif (D[i][s] <= eps) continue;",
			"\t\t\t\tif (r == -1 || MP(D[i][n+1] / D[i][s], B[i])",
			"\t\t\t\t             < MP(D[r][n+1] / D[r][s], B[r])) r = i;",
			"\t\t\t}",
			"\t\t\tif (r == -1) return false;",
			"\t\t\tpivot(r, s);",
			"\t\t}",
			"\t}",
			"",
			"\tT solve(vd &x) {",
			"\t\tint r = 0;",
			"\t\trep(i,1,m) if (D[i][n+1] < D[r][n+1]) r = i;",
			"\t\tif (D[r][n+1] < -eps) {",
			"\t\t\tpivot(r, n);",
			"\t\t\tif (!simplex(2) || D[m+1][n+1] < -eps) return -inf;",
			"\t\t\trep(i,0,m) if (B[i] == -1) {",
			"\t\t\t\tint s = 0;",
			"\t\t\t\trep(j,1,n+1) ltj(D[i]);",
			"\t\t\t\tpivot(i, s);",
			"\t\t\t}",
			"\t\t}",
			"\t\tbool ok = simplex(1); x = vd(n);",
			"\t\trep(i,0,m) if (B[i] < n) x[B[i]] = D[i][n+1];",
			"\t\treturn ok ? D[m][n+1] : inf;",
			"\t}",
			"};",
			"",
			"$0",
		],
	},
	"kactl/numerical/NumberTheoreticTransform.h": {
		"scope": "cpp",
		"prefix": "kactl/numerical/NumberTheoreticTransform.h",
		"body": [
			"${1:#include \"../number-theory/ModPow.h\"}",
			"/**",
			" * Author: chilli",
			" * Date: 2019-04-16",
			" * License: CC0",
			" * Source: based on KACTL's FFT",
			" * Description: ntt(a) computes \\$\\hat f(k) = \\sum_x a[x] g^{xk}\\$ for all \\$k\\$, where \\$g=\\text{root}^{(mod-1)/N}\\$.",
			" * N must be a power of 2.",
			" * Useful for convolution modulo specific nice primes of the form \\$2^a b+1\\$,",
			" * where the convolution result has size at most \\$2^a\\$. For arbitrary modulo, see FFTMod.",
			"   \\texttt{conv(a, b) = c}, where \\$c[x] = \\sum a[i]b[x-i]\\$.",
			"   For manual convolution: NTT the inputs, multiply",
			"   pointwise, divide by n, reverse(start+1, end), NTT back.",
			" * Inputs must be in [0, mod).",
			" * Time: O(N \\log N)",
			" * Status: stress-tested",
			" */",
			"",
			"const ll mod = (119 << 23) + 1, root = 62; // = 998244353",
			"// For p < 2^30 there is also e.g. 5 << 25, 7 << 26, 479 << 21",
			"// and 483 << 21 (same root). The last two are > 10^9.",
			"typedef vector<ll> vl;",
			"void ntt(vl &a) {",
			"\tint n = sz(a), L = 31 - __builtin_clz(n);",
			"\tstatic vl rt(2, 1);",
			"\tfor (static int k = 2, s = 2; k < n; k *= 2, s++) {",
			"\t\trt.resize(n);",
			"\t\tll z[] = {1, modpow(root, mod >> s)};",
			"\t\trep(i,k,2*k) rt[i] = rt[i / 2] * z[i & 1] % mod;",
			"\t}",
			"\tvi rev(n);",
			"\trep(i,0,n) rev[i] = (rev[i / 2] | (i & 1) << L) / 2;",
			"\trep(i,0,n) if (i < rev[i]) swap(a[i], a[rev[i]]);",
			"\tfor (int k = 1; k < n; k *= 2)",
			"\t\tfor (int i = 0; i < n; i += 2 * k) rep(j,0,k) {",
			"\t\t\tll z = rt[j + k] * a[i + j + k] % mod, &ai = a[i + j];",
			"\t\t\ta[i + j + k] = ai - z + (z > ai ? mod : 0);",
			"\t\t\tai += (ai + z >= mod ? z - mod : z);",
			"\t\t}",
			"}",
			"vl conv(const vl &a, const vl &b) {",
			"\tif (a.empty() || b.empty()) return {};",
			"\tint s = sz(a) + sz(b) - 1, B = 32 - __builtin_clz(s),",
			"\t    n = 1 << B;",
			"\tint inv = modpow(n, mod - 2);",
			"\tvl L(a), R(b), out(n);",
			"\tL.resize(n), R.resize(n);",
			"\tntt(L), ntt(R);",
			"\trep(i,0,n)",
			"\t\tout[-i & (n - 1)] = (ll)L[i] * R[i] % mod * inv % mod;",
			"\tntt(out);",
			"\treturn {out.begin(), out.begin() + s};",
			"}",
			"",
			"$0",
		],
	},
	"kactl/numerical/PolyRoots.h": {
		"scope": "cpp",
		"prefix": "kactl/numerical/PolyRoots.h",
		"body": [
			"${1:#include \"Polynomial.h\"}",
			"/**",
			" * Author: Per Austrin",
			" * Date: 2004-02-08",
			" * License: CC0",
			" * Description: Finds the real roots to a polynomial.",
			" * Usage: polyRoots({{2,-3,1}},-1e9,1e9) // solve x^2-3x+2 = 0",
			" * Time: O(n^2 \\log(1/\\epsilon))",
			" */",
			"",
			"vector<double> polyRoots(Poly p, double xmin, double xmax) {",
			"\tif (sz(p.a) == 2) { return {-p.a[0]/p.a[1]}; }",
			"\tvector<double> ret;",
			"\tPoly der = p;",
			"\tder.diff();",
			"\tauto dr = polyRoots(der, xmin, xmax);",
			"\tdr.push_back(xmin-1);",
			"\tdr.push_back(xmax+1);",
			"\tsort(all(dr));",
			"\trep(i,0,sz(dr)-1) {",
			"\t\tdouble l = dr[i], h = dr[i+1];",
			"\t\tbool sign = p(l) > 0;",
			"\t\tif (sign ^ (p(h) > 0)) {",
			"\t\t\trep(it,0,60) { // while (h - l > 1e-8)",
			"\t\t\t\tdouble m = (l + h) / 2, f = p(m);",
			"\t\t\t\tif ((f <= 0) ^ sign) l = m;",
			"\t\t\t\telse h = m;",
			"\t\t\t}",
			"\t\t\tret.push_back((l + h) / 2);",
			"\t\t}",
			"\t}",
			"\treturn ret;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/numerical/MatrixInverse-mod.h": {
		"scope": "cpp",
		"prefix": "kactl/numerical/MatrixInverse-mod.h",
		"body": [
			"${1:#include \"../number-theory/ModPow.h\"}",
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2016-12-08",
			" * Source: The regular matrix inverse code",
			" * Description: Invert matrix \\$A\\$ modulo a prime.",
			" * Returns rank; result is stored in \\$A\\$ unless singular (rank < n).",
			" * For prime powers, repeatedly set \\$A^{-1} = A^{-1} (2I - AA^{-1})\\  (\\text{mod }p^k)\\$ where \\$A^{-1}\\$ starts as",
			" * the inverse of A mod p, and k is doubled in each step.",
			" * Time: O(n^3)",
			" * Status: Slightly tested",
			" */",
			"",
			"int matInv(vector<vector<ll>>& A) {",
			"\tint n = sz(A); vi col(n);",
			"\tvector<vector<ll>> tmp(n, vector<ll>(n));",
			"\trep(i,0,n) tmp[i][i] = 1, col[i] = i;",
			"",
			"\trep(i,0,n) {",
			"\t\tint r = i, c = i;",
			"\t\trep(j,i,n) rep(k,i,n) if (A[j][k]) {",
			"\t\t\tr = j; c = k; goto found;",
			"\t\t}",
			"\t\treturn i;",
			"found:",
			"\t\tA[i].swap(A[r]); tmp[i].swap(tmp[r]);",
			"\t\trep(j,0,n)",
			"\t\t\tswap(A[j][i], A[j][c]), swap(tmp[j][i], tmp[j][c]);",
			"\t\tswap(col[i], col[c]);",
			"\t\tll v = modpow(A[i][i], mod - 2);",
			"\t\trep(j,i+1,n) {",
			"\t\t\tll f = A[j][i] * v % mod;",
			"\t\t\tA[j][i] = 0;",
			"\t\t\trep(k,i+1,n) A[j][k] = (A[j][k] - f*A[i][k]) % mod;",
			"\t\t\trep(k,0,n) tmp[j][k] = (tmp[j][k] - f*tmp[i][k]) % mod;",
			"\t\t}",
			"\t\trep(j,i+1,n) A[i][j] = A[i][j] * v % mod;",
			"\t\trep(j,0,n) tmp[i][j] = tmp[i][j] * v % mod;",
			"\t\tA[i][i] = 1;",
			"\t}",
			"",
			"\tfor (int i = n-1; i > 0; --i) rep(j,0,i) {",
			"\t\tll v = A[j][i];",
			"\t\trep(k,0,n) tmp[j][k] = (tmp[j][k] - v*tmp[i][k]) % mod;",
			"\t}",
			"",
			"\trep(i,0,n) rep(j,0,n)",
			"\t\tA[col[i]][col[j]] = tmp[i][j] % mod + (tmp[i][j] < 0)*mod;",
			"\treturn n;",
			"}",
			"",
			"$0",
		],
	},
	"kactl/numerical/FastSubsetTransform.h": {
		"scope": "cpp",
		"prefix": "kactl/numerical/FastSubsetTransform.h",
		"body": [
			"/**",
			" * Author: Lucian Bicsi",
			" * Date: 2015-06-25",
			" * License: GNU Free Documentation License 1.2",
			" * Source: csacademy",
			" * Description: Transform to a basis with fast convolutions of the form",
			" * \\$\\displaystyle c[z] = \\sum\\nolimits_{z = x \\oplus y} a[x] \\cdot b[y]\\$,",
			" * where \\$\\oplus\\$ is one of AND, OR, XOR. The size of \\$a\\$ must be a power of two.",
			" * Time: O(N \\log N)",
			" * Status: stress-tested",
			" */",
			"void FST(vi& a, bool inv) {",
			"\tfor (int n = sz(a), step = 1; step < n; step *= 2) {",
			"\t\tfor (int i = 0; i < n; i += 2 * step) rep(j,i,i+step) {",
			"\t\t\tint &u = a[j], &v = a[j + step]; tie(u, v) =",
			"\t\t\t\tinv ? pii(v - u, u) : pii(v, u + v); // AND",
			"\t\t\t\t// inv ? pii(v, u - v) : pii(u + v, u); // OR /// include-line",
			"\t\t\t\t// pii(u + v, u - v);                   // XOR /// include-line",
			"\t\t}",
			"\t}",
			"\t// if (inv) for (int& x : a) x /= sz(a); // XOR only /// include-line",
			"}",
			"vi conv(vi a, vi b) {",
			"\tFST(a, 0); FST(b, 0);",
			"\trep(i,0,sz(a)) a[i] *= b[i];",
			"\tFST(a, 1); return a;",
			"}",
			"",
			"$0",
		],
	},
}
